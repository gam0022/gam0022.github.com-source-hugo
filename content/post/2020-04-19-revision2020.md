+++
image = "/images/posts/2020-04-19-revision2020/resimulated-collage.jpg"
toc = true
math = false
draft = false
tags = ["event", "CG", "レイマーチング", "Revision", "WebGL", "GLSL", "TypeScript", "JavaScript"]
title = "Revision2020 PC 64K Intro 優勝作品『RE: SIMULATED』の技術解説"
slug = "revision2020"
date = "2020-04-19T20:31:34+09:00"

+++

4月10日～4月13日に開催された世界最大のデモパーティ[Revision2020](https://2020.revision-party.net/start)に参加して、『RE: SIMULATED by gam0022 & sadakkey』という作品を発表しました。

本作品が[PC 64K Intro](https://2020.revision-party.net/competitions/pc-competitions)という64KBの容量制限のある部門で参加者投票により1位に選ばれて優勝しました！

映像は私（[@gam0022](https://twitter.com/gam0022)）、音楽はさだきちさん（[@sadakkey](https://twitter.com/sadakkey)）の担当で制作しました。

![resimulated-collage](/images/posts/2020-04-19-revision2020/resimulated-collage.jpg)

<!--more-->

# 作品紹介

WebGLとWebAudioによる64K Introなので、最新のChromeと高性能なGPUがあれば、ブラウザ上で動作します。

- [64KB HTML version](https://gam0022.net/webgl/64k-intro_resimulated.html)
- [NEORT version](https://neort.io/art/bqa4pgs3p9f6qoqnmujg)

26KBの単一のHTMLファイルだけで完全に動作するデモとなっています。

今回が64K部門のエントリーは初めてということもあり、どのくらいのコンテンツが詰め込めるか感覚がつかめず、うまく調整できずに容量を半分以上も余らせてしまいました…

<blockquote class="twitter-tweet" data-conversation="none"><p lang="ja" dir="ltr">実は26KBしか使いきれなかったので、次回は64KBギリギリまで使えるように精進します💪 <a href="https://t.co/uxF2M5DZmg">pic.twitter.com/uxF2M5DZmg</a></p>&mdash; がむ / encoder killer (@gam0022) <a href="https://twitter.com/gam0022/status/1249677712815321088?ref_src=twsrc%5Etfw">April 13, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

スペックの高いPCを持っていない方は、YouTubeの動画をご覧ください。

フラクタルをつかった映像のビットレートの高い作品ですが、4K解像度を選ぶことである程度は綺麗な状態で見れます。

<div class="movie-wrap">
<iframe width="1920" height="1080" src="https://www.youtube.com/embed/tirAdWbceak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

---

こちらはpouet（デモシーンのコミュニティサイト）のリンクです。

- [RE: SIMULATED by Gam0022 &amp; Sadakkey :: pouët.net](https://www.pouet.net/prod.php?which=85260)

## Revisionとは

2020年現在、世界最大規模のデモパーティです。

例年ドイツで開催されていましたが、[今年はコロナウイルスの影響で完全オンラインでの開催](https://2020.revision-party.net/cancellation)となりました。

しかし、そんな中でも[世界中から1610人が参加](https://2020.revision-party.net/about/visitors)する大規模なイベントになりました。

## 今年のPC 64K Intro部門

日本人のチームがPC 64K Intro部門で優勝するのは Revision 史上初です。

去年のPC 64K Introは本当にレベルが高かったのですが、今年は優勝候補チームが他の部門に分散したために、競争相手が少なかったので自分のレベルでも優勝できたという感じです。

自分の作品だけを見てPC 64K Introのレベルを判断されるのは本意ではないので、去年のPC 64K Introの優勝作品のYouTubeのリンクを紹介しておきます。これが本来のPC 64K Introのレベルです！

- [Dope on Wax by Logicoma (PC 64k) [party version]](https://youtu.be/QhqT0DhV9yE)

実力ではなく運で優勝してしまったのですが、尊敬するデモチームの方々にたくさんの称賛のコメントをいただけたので、とても光栄に思います！

そもそも優勝するとは微塵にも思っておらず、海外勢にも少しでも名前を覚えてもらえたら嬉しいなぁくらいのノリでエントリーしたのに、まさか優勝してしまうとは…

# 技術解説

さて、ここから本題の技術解説に入っていきます。

ソースコードはすべてGitHubに公開しているので、興味がある方はぜひ見てください。

- [gam0022/resimulated: 1st place at Revision 2020 (PC 64K Intro)](https://github.com/gam0022/resimulated)

キーワードとしては、以下の技術が使われています。

TypeScript, WebGL, WebAudio, webpack, pnginator.rb, Raymarching, GLSL Sound

## シンプルなWebGLエンジン『Chromatiq』

64KBの容量制約があるため、Unityやthree.jsといった既存のゲームエンジンやフレームワークを利用せずに、描画用のWebGLエンジンと制作用のツール（エディタ機能）を自作する必要がありました。

OpenGLやDirectXを使わずに、WebGLを選択した理由は以下です。

- WebGLでブラウザ上で動かせれば、手元のPCで動かしてもらえる可能性が高いと考えた
    - 自分の作品は映像のビットレートが高く、動画だと綺麗にならないため、手元のPCで実行して見てもらいたい
- Webフロントエンドの技術をキャッチアップしたかった
    - 業務ではUnityしか触る機会がない

そこで、64K Intro向けにファイルサイズの最小化を目的としたシンプルなWebGLエンジンである『Chromatiq』を開発しました。

WebGLエンジンとは言うものの、本当にシンプルで最小限な機能しか "現段階では" 実装していません。

なるべく作品に依存した機能は用意したくなかったので、汎用的な設計になっています。

- マルチパスのImageShaderによるレンダリング（viewport square）
- ビルドインのBloomのポストエフェクト
    - どんな作品でも利用できそうなので、これだけビルドインにした
- TypeScriptからuniformをアニメーションするためのインターフェース
- Shadertoyと互換性のあるGLSL Sound
- オーディオファイルの再生（mp3 / ogg）
    - 今回は先にDAWで作曲し、後からGLSLに移植する作戦にしたので、DAWによる音楽の再生用の機能
- フォントをレンダリングするためのcanvasからのテクスチャ生成

イメージとしてはGLSLエディタを排除したスタンドアローンなShadertoyが近いかもしれません。

ソースコードは[こちら](https://github.com/gam0022/resimulated/blob/master/src/chromatiq.ts)です。単一ファイルのTypeScriptで実装しました。

圧縮後のコードサイズを気にして、変な感じの実装になっているので、微妙に読みづらいかもしれません。

例えば、フィールド参照の this を頭につけるとコードサイズが増えるため、コンストラクタの中で動的にインスタンスメソッドを定義することで、this の利用を最小限にしたり、
クラス外から値を参照・設定する必要があるデータのみ、フィールドとして定義する方針とています。enumもコードサイズが増えるので禁止にしました。

製作の終盤から容量が余裕そうなことが判明したので、途中からファイルサイズを考慮するのを止め、mini化の中途半端感は否めないです。
このあたりは、次のデモに向けて改良していきたいと考えています。

uniform名は基本的にはShadertoyと一致させているのですが、テクスチャのサンプラーはShadertoyを踏襲せずに、直前のパスを参照する `iPrevPass` を定義しました。
これによってGLSLを書き換えずにエフェクトの順番を入れ替えたり、気軽にパスを増やしてエフェクトをチェインしやすくしました。
このあたりの仕様も、作品の需要に応じて変更していく可能性は高いです。

## ファイル圧縮のためのビルドプロセス

圧縮には[webpack](https://webpack.js.org/)と[pnginator.rb](https://gist.github.com/gasman/2560551)を利用しています。

ビルドプロセスを図にしました。

![build-process](/images/posts/2020-04-19-revision2020/build-process.svg)

webpackですべてのファイルをbundle.jsという単一のJavaScriptに固めてから、pnginator.rbで自己解凍形式のPNGにしています。

TypeScriptのminifyは完全にwebpack任せです。

pnginator.rbはgasmanさんが作ったJavaScriptを自己解凍形式のPNGにパックするツールです。

PNGでは画像データをzlib圧縮するため、画像データではなくても、例えば今回のようなプログラムのソースコードでちゃんと圧縮できます。

[GLSLのminifyも検証](https://qiita.com/gam0022/items/364c7f76f2787e385161)はしていて、webpackのLoaderを開発する予定もあったのですが、容量が余裕だったのでGLSLの圧縮はPNG（zlib）だけになりました。

また、開発用にしか必要ないコードの削除もwebpackの[define-plugin](https://webpack.js.org/plugins/define-plugin/)で実現できました。

webpackとpnginator.rbを組み合わせる手法は、FMS_Catさんの[Until](https://github.com/FMS-Cat/until/)を参考にしました。ありがとうございます！

当初はnode.jsでGLSLのホットリロード機能付きのWebサーバを開発しようと技術検証していたのですが、
要件は[webpack-dev-server](https://github.com/webpack/webpack-dev-server)ですべて実現可能だったので、webpackを採用しました。

## 制作用のエディタ機能の紹介

[![chromatiq-editor](/images/posts/2020-04-19-revision2020/chromatiq-editor.png)](/images/posts/2020-04-19-revision2020/chromatiq-editor.png)

製作のイテレーションを高速化するため、必要なエディタ機能は一通り実装しました。

- 再生位置のシーク機能
    - 再生・一時停止・停止・フレームのコマ送り・時間の表示単位の秒とビートの切り替え
- GLSLやTypeScriptのホットリロード機能
- uniformのパラメータのインスペクタ
- カメラの自由移動
- デバッグ用に特定のパスの表示

エディタ機能については、容量の制約とは関係ないので、既存の便利なライブラリも積極的に利用しました。

- ボタン用のアイコンのために、[fontawesome](https://fontawesome.com/)
- uniformのパラメータのインスペクタのために、[dat.gui](https://github.com/dataarts/dat.gui)
- カメラの自由移動のために、[three.js](https://threejs.org/)の[OrbitControls](https://threejs.org/docs/#examples/en/controls/OrbitControls)

### uniformのパラメータのインスペクタ

スクリーンショットの右上のように、GLSL上で以下のようなuniformを宣言するだけで、そのままインスペクタに表示されるような仕組みを実装しました。

コメントでは左から順に `初期値 min max カテゴリー名` を指定しています。初期値は必須ですが、それ以外は省略可能としました。

```c
uniform float gEmissiveIntensity;     // 6.0 0 20 emissive
uniform float gEmissiveSpeed;         // 1 0 2
uniform float gEmissiveHue;           // 0.33947042613522904 0 1
uniform float gEmissiveHueShiftBeat;  // 0 0 1
uniform float gEmissiveHueShiftZ;     // 0 0 1
uniform float gEmissiveHueShiftXY;    // 0 0 1
```

私の作品では、フラクタルやIFSといったパラメータの細かな調整が重要になる表現を多用しているため、気軽にパラメータを増やして、気軽に値を調整できるようにしました。

値の当たりをつけた後に、パラメータのアニメーションを[TypeScriptのコード](https://github.com/gam0022/resimulated/blob/master/src/index.common.ts#L142-L569)に落とし込むワークフローにしました。

### 動画の保存機能

処理落ちなしに4K解像度で動画を出力したかったので、以下の機能も用意しました。

- 画像の連番保存機能
- サウンドの wav 保存機能

最終的に連番画像とwavファイルをffmpegで .mp4 に変換してYouTubeにアップロードしました。

```bash
ffmpeg.exe -r 60 -i chromatiq%04d.png -i chromatiq.wav -c:v libx264 -preset slow -profile:v high -coder 1 -pix_fmt yuv420p -movflags +faststart -g 30 -bf 2 -c:a aac -b:a 384k -profile:a aac_low -b:v 68M chromatiq_68M.mp4
```

## 映像について

普通にレイマーチングをしているだけなので、このブログの読者にとっては、特筆するようなことはやっていません。

前半のサイバーなシーンはMandelboxをベースにしました。

後半の宇宙空間とグリーティングのシーンでは、宇宙空間はレイマーチング、惑星の上のグリーティングの文字はAABBとして解析的に衝突判定をするハイブリッドなレイトレをしています。

パスの構成は、最終的にこうなりました。

1パス目と2パス目を分離したのは、シェーダーのコンパイル時間の短縮のためです。

- 1パス目: 前半のシーンのレイマーチング
- 2パス目: 後半のシーンのレイマーチング
- 3パス目: テキストの描画
- 4～13パス目: Bloomのポストエフェクト
- 14パス目: ポストエフェクトとトーンマッピング

## 音楽について

GLSLサウンドを鳴らす仕組みについては、[amagiさん](https://twitter.com/amagitakayosi)の記事を参考にして、Shadertoy互換のGLSLサウンドの再生機能を実装しました。ありがとうございます！

- [VEDA 2.4: GLSLで音楽を演奏できるようになったぞ！！！ - マルシテイア](https://blog.amagi.dev/entry/veda-sound)

音楽はさだきちさんにGLSLサウンドを実装していただきました。

さだきちさんはプログラミングもGLSLも今回が初挑戦だったので、簡易的なサウンド用のシーケンサーを自分がGLSLで実装して、それをさだきちさんが利用する作戦でGLSLサウンドを実装していただきました。

自分がGLSLサウンドで担当したのはシーケンサーの仕組み部分だけで、それ以外のオシレーターの関数やメロディの実装については、すべてさだきちさんが担当しました。

### サウンド用のシーケンサーの利用例

これはベースのパートの波形を生成するGLSLの関数です。

```c
vec2 bass1(float beat, float time) {
// 1つのパターンのビート数
#define BASS1_BEAT_LEN 8

// パターンの種類
#define BASS1_DEV_PAT 10

// 楽曲全体の長さのパターン数
#define BASS1_DEV_LEN 32

    // パターンの定義
    int[BASS1_BEAT_LEN * NOTE_DIV * BASS1_DEV_PAT] notes = int[](
        // パターン0
        F(0), F(33), E(0, 33), S(0, 33, 0, 33),
        F(0), F(33), E(0, 33), S(0, 33, 0, 33),

        // パターン1
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),

        // パターン2
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),
        E(29, 29), S(0, 29, 29, 29), S(0, 31, 31, 31), S(48, 47, 43, 40),

        // パターン3
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 34, 34, 34),

        // パターン4
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 36, 36, 36),

        // パターン5
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),
        E(33, 33), S(0, 33, 33, 33), S(0, 34, 34, 34), S(0, 36, 36, 36),

        // パターン6
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),
        E(33, 33), S(0, 33, 33, 33), S(0, 43, 43, 43), S(0, 55, 57, 69),

        // パターン7
        E(29, 29), S(0, 29, 29, 29), S(0, 29, 29, 29), S(0, 31, 33, 45),
        E(29, 29), S(0, 29, 29, 29), S(0, 29, 29, 29), S(0, 31, 31, 31),

        // パターン8
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33),
        E(33, 33), S(0, 33, 33, 33), S(0, 33, 33, 33), S(0, 43, 45, 57),

        // パターン9
        E(29, 29), S(0, 29, 29, 29), S(0, 29, 29, 29), S(0, 31, 33, 45),
        E(29, 29), S(0, 29, 29, 29), S(0, 31, 31, 31), S(0, 31, 31, 31));

    // パターンの進行
    int[BASS1_DEV_LEN / DEV_PACK] development = int[](
        D(0, 0, 0, 0, 0, 0, 0, 0), D(1, 1, 1, 2, 3, 4, 5, 6),
        D(7, 0, 7, 8, 7, 0, 9, 0), D(0, 0, 0, 0, 0, 0, 0, 0));

    SEQUENCER(beat, time, BASS1_BEAT_LEN, BASS1_DEV_PAT, BASS1_DEV_LEN,
        notes, development, bass)

    return ret;
}
```

パターン（2小節分のノートナンバーの並び）の定義、パターンの進行 を配列で指定できるようにて、4種類の音の長さに対応しました。

- O: 全音符
- F: 4分音符
- E: 8分音符
- S: 16分音符

ノートナンバーに0を指定すると休符になります。

`O, F, E, S` は関数マクロとなっていて、16分音符を音の最小単位として、16bitごとにノートナンバー(8bit)と音の長さ(8bit)をパッキングしています。

GLSLのintは32bitなので、int配列の1要素に16分音符は2つ、8分音符が1つ入るような設計です。

GLSLのコンスタントバッファのサイズには制限があり、全体で4096個まで要素数の配列までしか宣言ができなかったため、8bitずつパッキングすることにしました。

展開の `D` もマクロとなっていて、要素数の節約のために4bitずつパッキングをしています。

`bass` は時間とノートナンバーを入力として、波形を出力するオシレーターのGLSL関数です。

`SEQUENCER` は、時間、パターンの定義の配列、パターンの進行の配列、オシレーターの関数を指定することで、パートごとの波形を生成して `vec2 ret` に代入する関数マクロです。

GLSLでは関数を引数とするような高階関数は実現できませんが、関数マクロで擬似的に実現しました。

`SEQUENCER` の[実装](https://github.com/gam0022/resimulated/blob/master/src/shaders/sound-resimulated.glsl#L484-L506)はちょっと汚いですが、`bass1` などのパートごとの関数は非プログラマーでも実装できるような、分かりやすい仕組みを提供できたのではないかと自負しています。

## RE: SIMULATED の意味

作品のタイトルの『RE: SIMULATED』には2つの意味を込めました。

1. 前作『WORMHOLE』の64K Introとしての「再現」
2. SIMULATED REALITY

### 1. 前作『WORMHOLE』の64K Introとしての「再現」

一昨年のTokyoDemoFest 2018のCombined Demo Compoでも、さだきちさんとチームを組んで『WORMHOLE』という作品で優勝しました（[記事](https://gam0022.net/blog/2018/12/12/tdf2018/)）。

前半のシーンが顕著ですが、『WORMHOLE』と表現や演出が酷似していると思います。

- フラクタルの形状変化
- 光の色の変化
- シーン転換前の激しい点滅
- シーン転換後のホワイトイン
- パーティのロゴの登場

WORMHOLEはUnityで制作した作品だったので、60.7 MB（zip圧縮で 23.18MB）というファイルサイズでした。

今回は自作のシステムで作品を制作することでファイルサイズは26KBになりました。

同じ表現を「再現」しつつも、容量を 1/2334 まで圧縮する試みのコンセプトは達成できました。

まさか、コンポで優勝するという結果まで「再現」してしまうのは予想外でした（笑）

### 2. SIMULATED REALITY

[Simulated Reality](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%9F%E3%83%A5%E3%83%AC%E3%83%BC%E3%83%86%E3%83%83%E3%83%89%E3%83%BB%E3%83%AA%E3%82%A2%E3%83%AA%E3%83%86%E3%82%A3)という裏コンセプトもありました。

作品の最後に「RE: SIMULATED」の文字が

`RE: SIMULATED` → `RE` → `REALITY`

と変化して、REALITYに変化するタイミングで「地球」がフラッシュバックするのは、Simulated Realityの暗喩です。

前半のサイバーなシーンは電子的な仮想空間という設定で、シーン転換時に球体が空間が歪んで爆発するのは宇宙誕生のビッグバンの暗喩です。

この世界は上位存在によって電子的にシミュレーションされた仮想現実で、最後に自分たちが住む地球を見つけるというストーリーでした（あくまで裏設定だったので、見た人に通じなくても良い）。

できれば現実と見分けがつかないようなリアルなグラフィックで表現できたら良かったのですが、力量不足でした…

# おわりに