+++
draft = false
tags = [
  "CG", "レイトレーシング", "パストレーシング", "Rust"
]
title = "レイトレ合宿5‽に参加しました！"
slug = "rtcamp5"
date = "2017-09-18T19:29:40+09:00"
image = "/images/posts/2017-09-18-rtcamp5/result.png"
toc = true
math = false

+++

9月9日(土)～9月10日(日)に諏訪湖で開催された[レイトレ合宿5‽](https://sites.google.com/site/raytracingcamp5/)に参加しました！

去年に初参加させていただき、今年で2回目の参加になります。去年の参加報告は[こちら](http://gam0022.hatenablog.com/entry/raytracingcamp4)です。

今年もレンダリング分野の最先端でご活躍されている方々がたくさん参加されていました。
Redqueenレンダラーの開発者で現在はAutodeskでArnoldレンダラーの開発に携わっている大垣真二さん、
[SIGGRAPH 2017にレンダリングの論文がアクセプト](http://lightmetrica.org/h-otsu/project/inverse/)された研究者のHisanari Otsuさんなどが参加されていました。

猛者ばかり中、私はRustでパストレーサ（hanamaru-renderer）を実装して、なんとか9位をいただきました！

こんな感じの画像をレンダリングしました。

[![result](/images/posts/2017-09-18-rtcamp5/result.png)](/images/posts/2017-09-18-rtcamp5/result.png)

この記事では自作のパストレーサの解説を中心に紹介します。

ソースコードはGitHubに公開しています。

- [https://github.com/gam0022/hanamaru-renderer/](https://github.com/gam0022/hanamaru-renderer/)

こちらは合宿当日のプレゼン資料です。

<script async class="speakerdeck-embed" data-slide="1" data-id="6159e679b62d4d87a718fdf97efe5ed8" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

# 主な仕様

- ポリゴンメッシュに対応
    - obj ファイルの読み込み
    - BVHで衝突判定を高速化
- albedo / roughness / emission をテクスチャで指定可能
    - PBR用のテクスチャ素材などを使える
- 薄レンズモデルによる被写界深度（レンズのピンぼけ）
- Image Based Lighting
    - CubeMapに対応

# シーンの解説



# パストレーシングの高速化

今年の合宿では4分33秒以内にレンダリングするルールがあったため、最低限の高速化には取り組みました。

出力画像の解像度についてはルールは決まっていませんでしたが、1980x1080を採用しました。

パストレーシングの高速化のアプローチには主に2通りあります。

1. 衝突判定の高速化
2. モンテカルロ積分のサンプリングの効率化

それぞれ何を行ったのか簡単に紹介します。

## 衝突判定の高速化

衝突判定の高速化としてはBVH（Bounding Volume Hierarchy）を実装しました。

シーン内のすべてのオブジェクトを総当りで衝突判定せずに、空間分割によって衝突判定の回数を減らします。

具体的な実装などについては、[お餅](https://twitter.com/omochi64)さんの記事を参考にしました。

- [Bounding Volume Hierarchy (BVH) の実装 - 構築編](http://qiita.com/omochi64/items/9336f57118ba918f82ec)
- [Bounding Volume Hierarchy (BVH) の実装 - 交差判定編](http://qiita.com/omochi64/items/c2bbe92d707b280896fd)

お餅さんの記事では、Surface Area Heuristicsという手法で評価関数をつかった領域分割をしていましたが、
今回は実装の時間が無かったので、領域の最長辺を軸に選んで要素数で2分割する実装にしました。
単純な分割方法ではありますが、総当りと比較すれば十分に高速化できました。

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">全探索だと251.251 sec<br>軸をランダムに選んでポリゴンを2等分するBVHだと 36.28 sec<br>AABBの最長辺を軸に選んでポリゴンを2等分するBVHだと 28.424 sec</p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/896963950947975168">2017年8月14日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

## モンテカルロ積分のサンプリングの効率化

サンプリングの効率化のための手法としては、重点的サンプリング、多重重点的サンプリング、Next Event Estimationなどがあります。

詳しくは[Shocker](https://twitter.com/Shocker_0x15)さんの資料を参照してください。

<iframe src="//www.slideshare.net/slideshow/embed_code/key/aoZ5RhsL8f6NPC" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/shocker_0x15/ss-52688052" title="パストレーシング" target="\_blank">パストレーシング</a> </strong> from <strong><a href="https://www.slideshare.net/shocker_0x15" target="\_blank">Shin Watanabe</a></strong> </div>

今回はレンダリング方程式のcos項に比例した重点的サンプリングのみ行いました。

レンダリング方程式のcos項に比例した重点的サンプリングを行うと、
確率密度関数で除算する処理でレンダリング方程式のcos項を打ち消すことができ、パストレーシング実装をシンプルにできます。

今回のシーンではIBL光源が支配的なため、cos項に比例した重点的サンプリングのみで十分な速度でレンダリングの収束しましたが、
光源が小さいシーンだと分散が大きくなりすぎて収束が遅くなるはずです。

来年までにはNext Event Estimationに挑戦してみたいです。

# 開発中の振り返り

## Rustについて

去年はC++で開発したのですが、新しい言語を触ってみたいというモチベーションが高まっていたので、Rustで0から開発することにしました。

Rustについて何も知らなかったので、まずは通勤中に[プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/README.html)を読んでRustの思想を学びました。

Rustにはcargoというビルドツール兼パッケージ管理システムが標準搭載されていて、これはとても便利でした。
`cargo run`を叩くだけで、自動的にパッケージをフェッチし、依存関係を解決してビルドと実行ができます。

開発前半は通勤中にMacで開発して、開発後半は高スペックなWindowsデスクトップに開発環境を移行しました。
cargoのおかげでMacもWindowsも同じようにビルドができるので、開発環境を行き来するコストが全くありませんでした。

一方でRustの学習コストはやはり高いと感じました。
Rustの予習に1週間かけましたが、いざコードを書いてみると所有権や型のサイズが不定などのコンパイルエラーに阻まれて、心が折れそうになりました。
特に所有権やライフタイムは自分には全く馴染みの無い概念で理解するのに苦労させられました。

最初は大変でしたが、慣れてくればコンパイルエラーに阻まれることはなくりました。
所有権を意識することでコードもスッキリしました。

Rustは所有権という仕組みによってデータ競合を排除したり、ガーベジコレクタなしを実現しているので、
この辺は「学習コスト」対「安全性＋実行時パフォーマンス」のトレードオフだろうと感じました。

C++の経験がある人は[Rustは何が新しいのか（基本的な言語機能の紹介） - いもす研 (imos laboratory)](https://imoz.jp/note/rust-functions.html)という記事を読むとRustがどういう言語なのか雰囲気を掴めると思いました。

細かい話になりますが、[列挙型](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/enums.html)は良いと思いました。
Cのenumとは違って、構造体やタプルのような各ヴァリアントに関連するデータを持たせることができるので、マテリアルのタイプの定義に便利でした。

```rust
#[derive(Clone, Debug)]
pub enum SurfaceType {
    Diffuse,
    Specular,
    Refraction { refractive_index: f64 },
    GGX { roughness: f64 },
    GGXReflection { roughness: f64, refractive_index: f64 },
}
```

https://github.com/gam0022/hanamaru-renderer/blob/d4eb5320fbe9ed18de152496c6e3aa070e947dfb/src/material.rs

他にも[リスト処理](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/iterators.html)も充実していて好感が持てました。

Rustの開発環境は[IntelliJにRustのプラグイン](https://intellij-rust.github.io/)をインストールするのが最強だと思いました。
関数定義にジャンプできるのはもちろん、メソッド名の補完やリファクタリングなども普通に使えます。

## デバッグ機能

後半になるとシーンの編集作業がメインになってくるのですが、シーンの確認のために何分も待機するのは大変です。
そこで高速にレンダリングするモードを開発初期から準備しました。
それ以外にも法線や深度値、焦点面からの距離などを表示するモードを実装して、シーン編集の効率を向上させました。

![debug](/images/posts/2017-09-18-rtcamp5/debug.jpg)

## 制作の過程

モチベーション維持のために進捗を細かくTwitterにアップロードするようにしました。

徐々にステップアップしていく様子を自分でも振り返ることができたので、便利でした。

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">土日はRustを頑張っていた。<br>鬼門と噂の所有権や借用については、予習してきたので、思ったより苦労せずに済んだ。<br>Rustはスタック領域にメモリ確保するので、structのサイズが事前に分かってないとコンパイルできない仕様に悩まされた(Box&lt;T&gt;で解決)。</p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/891665053644054529">2017年7月30日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">Rustで生成した最初の画像<br>image crateが超便利だった。 <a href="https://t.co/ZCZrg05ms6">pic.twitter.com/ZCZrg05ms6</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/891665290659889153">2017年7月30日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">なんとかレイを飛ばすことに成功した図<br>Rust、慣れるまでがやっぱり大変だった...<br>実装1割、コンパイル通すの9割みたいな時間配分ｗ <a href="https://t.co/bmD8pwaWRR">pic.twitter.com/bmD8pwaWRR</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/891665866089091072">2017年7月30日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">Planeを実装。<br>スクリーン上のY軸を反転させるのを忘れていて、座標系が何もかもバグってたのを修正。<br>ずっと床が無い状態だったので気がつけなかった…ｗ<br>影もつけた。 <a href="https://t.co/MKtlNsBHyB">pic.twitter.com/MKtlNsBHyB</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/891723700139024384">2017年7月30日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">パストレができるようになった。<br>Rayonで並列処理も実現できた。<br>Macでコード書いていたけど、rustupでWindowsにRustインストールしたら、手直し0でcargo buildでWindows用バイナリ生成できた。Rust良いね。 <a href="https://t.co/VhIqlu1bqe">pic.twitter.com/VhIqlu1bqe</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/893725960180187137">2017年8月5日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">SuperSampling + IBL実装<br>フルスクラッチでCubeTexture実装したことなかったので、画像の向きが滅茶苦茶になるのを治すのに苦労した。<br>Bilinearフィルター実装しないとジャギがやばいね… <a href="https://t.co/zZIl36eXEV">pic.twitter.com/zZIl36eXEV</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/893889557027987456">2017年8月5日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">Bilinearフィルターできた。<br>一度もバグらせることなく実装できたので良かった。 <a href="https://t.co/462rdPWGjP">pic.twitter.com/462rdPWGjP</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/894090372707606528">2017年8月6日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">GGXと屈折できた〜<br>右の紫はGGX+屈折の磨りガラスにしているけど、床が単色だから普通の屈折面と区別がつかないw <a href="https://t.co/jlNaPeWRI6">pic.twitter.com/jlNaPeWRI6</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/894204969674391552">2017年8月6日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">テクスチャ対応とガンマ補正した。<br>エイリアシングが酷すぎるが、Mipmapの実装は今回は見送ろうかな <a href="https://t.co/XMGUbfJ3Ab">pic.twitter.com/XMGUbfJ3Ab</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/895954424656388097">2017年8月11日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">ポリゴンの衝突判定とobjファイルのローダを実装した。<br>モデルは1000ポリゴンに削ったスタンフォードバニー。<br>ついでに簡単なBVHも実装してポリゴンの衝突判定を高速化してみた。 <a href="https://t.co/7yWJQnnpyR">pic.twitter.com/7yWJQnnpyR</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/896963739412340736">2017年8月14日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">被写界深度（レンズのピンぼけ）をシミュレーションした。<br>薄レンズモデルで、絞り羽根は円形。<br>時間があれば、星型とか六角形とか、面白い絞り羽根も試してみたい。 <a href="https://t.co/YAkiJwF0WA">pic.twitter.com/YAkiJwF0WA</a></p>&mdash; がむ (@gam0022) <a href="https://twitter.com/gam0022/status/897685643672920064">2017年8月16日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

# まとめ
