<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gam0022.net</title>
    <link>https://gam0022.net/tags/shader/index.xml</link>
    <description>Recent content on gam0022.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <copyright>&amp;copy; 2016 gam0022</copyright>
    <atom:link href="/tags/shader/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Windows Terminalの背景でレイマーチング</title>
      <link>https://gam0022.net/blog/2021/03/08/raymarching-in-windows-terminal/</link>
      <pubDate>Mon, 08 Mar 2021 01:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2021/03/08/raymarching-in-windows-terminal/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-02-26-raymarching-in-windows-terminal/raymarching-in-windows-terminal.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-02-26-raymarching-in-windows-terminal/raymarching-in-windows-terminal.jpg&#34; alt=&#34;Raymarching in Windows Terminal&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows Terminal 1.6から任意のHLSLのPixel Shadersを実行できるようになったので、Windows Terminalの背景でレイマーチングを実行してみました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Raymarching in Windows Terminal&lt;br&gt;&lt;br&gt;Windows Terminal 1.6 から任意の Pixel Shaders を実行できるようになったので、Windows Terminal の背景でレイマーチングを実行してみた🎉 これは楽しすぎる🤣 &lt;a href=&#34;https://t.co/WX2JqUZtuL&#34;&gt;pic.twitter.com/WX2JqUZtuL&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361485111473045505?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;2021-02-16のツイート時点では、Windows Terminal 1.6はまだPreview版なので、GitHubのReleasesページから入手する必要がありました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/terminal/releases/tag/v1.6.10412.0&#34;&gt;https://github.com/microsoft/terminal/releases/tag/v1.6.10412.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2021-03-07現在では、Windows Terminal 1.6からPreviewが外れてMicrosoft Storeから入手できるようになりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.microsoft.com/ja-jp/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab&#34;&gt;Windows Terminal を入手 - Microsoft Store ja-JP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows TerminalのPixel Shaders機能の詳細については、公式ドキュメントをご覧ください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/terminal/tree/main/samples/PixelShaders&#34;&gt;https://github.com/microsoft/terminal/tree/main/samples/PixelShaders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任意のHLSLのシェーダーのファイルを作成して、Windows Terminalのsettings.jsonの &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; からHLSLファイルのパスを設定するだけで、気軽に任意のシェーダーを実行できます。素晴らしい！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;profiles&amp;quot;:
  {
    &amp;quot;defaults&amp;quot;:
    {
      &amp;quot;experimental.pixelShaderPath&amp;quot;: &amp;quot;C:\\Users\\gam0022\\Dropbox\\windows-terminal\\terminal\\samples\\PixelShaders\\Raymarching.hlsl&amp;quot;
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;レイマーチング用のシェーダーはUnityで下書きしたものをWindows Terminal用に移植して実装しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Raymarching in Windows Terminal のシェーダーを公開しました。&lt;br&gt;&lt;br&gt;（シェーダー初心者にも優しい）日本語コメントつき！&lt;a href=&#34;https://t.co/GPEpIlHOyD&#34;&gt;https://t.co/GPEpIlHOyD&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361495940356476929?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;HLSLのエラーの行番号が表示されないので、複雑なシェーダーを書くのはちょっと苦労しました。&lt;/p&gt;

&lt;p&gt;基本的にはUnityのShaderLab用のプロパティや &lt;code&gt;_LightColor0&lt;/code&gt; などのビルドインのシェーダー変数を定数（static const）として宣言する修正だけで移植できました。&lt;/p&gt;

&lt;p&gt;Windows Terminal用のPixel Shadersでは、以下のテクスチャのサンプラーや定数が定義されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// The terminal graphics as a texture
// ターミナルの文字などを含んだターミナルのレンダリング結果のサンプラー
Texture2D shaderTexture;
SamplerState samplerState;

// Terminal settings such as the resolution of the texture
cbuffer PixelShaderSettings {
  // The number of seconds since the pixel shader was enabled
  // 秒単位の時間
  float Time;

  // UI Scale
  // UIのスケール
  float Scale;
  
  // Resolution of the shaderTexture
  // ピクセル単位の背景の解像度
  float2 Resolution;
  
  // Background color as rgba
  // 背景の色
  float4 Background;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shaderTexture&lt;/code&gt; はターミナルの文字などを含んだターミナルのレンダリング結果のサンプラーになるので、今回は背景に加算合成する形でシェーダーを実装しました（加算合成なので後からレイマーチングを加算しても結果は同じになるため、描画順を気にしなてくて良い）。&lt;/p&gt;

&lt;h1 id=&#34;hlslのホットリロードでシェーダーライブコーディング環境を実現&#34;&gt;HLSLのホットリロードでシェーダーライブコーディング環境を実現&lt;/h1&gt;

&lt;p&gt;Windows Terminal 1.6の挙動では、シェーダーを再コンパイルして結果を更新するために以下の手順が必要だったので、ライブコーディングには不向きでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; で指定したHLSLシェーダーに差分を出してファイル保存&lt;/li&gt;
&lt;li&gt;Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; の &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; の値に差分を出してファイル保存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最初の動画ではシェーダーの描画結果をリアルタイムで更新するために、Vimで2つのファイルを同時編集することで、リアルタイムにライブコーディングっぽいことをしていましたが、かなり操作が忙しいので非実用的でした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vimの左側ペイン: HLSLのシェーダー&lt;/li&gt;
&lt;li&gt;Vimの右側ペイン: Windows Terminalのsettings.json&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そこで、HLSLの更新を検知して、Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; を書き換えることで、HLSLのホットリロードを実現するスクリプトをnode.jsで実装しました。&lt;/p&gt;

&lt;p&gt;これによって、Windows Terminalの背景でHLSLシェーダーライブコーディングを実現できるようになりました！&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Windows Terminal 上のHLSLシェーダーライブコーディング環境を実現するスクリプトをGitHubに公開しました！&lt;br&gt;&lt;br&gt;&amp;gt; HLSLの変更を監視して、settings.json を書き換え&lt;a href=&#34;https://t.co/hjB2MqgsSx&#34;&gt;https://t.co/hjB2MqgsSx&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361706800282656769?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; に毎回差分を出すために、HLSLファイルをコピーした一時ファイルを作成して、元のファイルのパスと一時ファイルのパスを交互に切り替えて &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; に設定するような実装としました。&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;Windows TerminalというMicrosoft公式のアプリ上でHLSLシェーダーライブコーディング環境を実現できるのは熱いですね！楽しい！！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Unity] Y軸ビルボードシェーダーの実装と解説</title>
      <link>https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/</link>
      <pubDate>Tue, 23 Jul 2019 09:30:09 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/</guid>
      <description>&lt;p&gt;こんな感じのY軸のビルボードをC#スクリプトを使わずに、シェーダーだけで実装しました（Unity 2018.3.12f1）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_y_axis.gif&#34; alt=&#34;Y軸ビルボード&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubリポジトリ: &lt;a href=&#34;https://github.com/gam0022/unity-legacy-render-pipeline-experiments/blob/master/Assets/Experiments/Billboard/Billboard.shader#L51-L82&#34;&gt;gam0022/unity-legacy-render-pipeline-experiments/blob/master/Assets/Experiments/Billboard&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;この記事の要約&#34;&gt;この記事の要約&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;頂点シェーダーでView行列の回転（カメラに応じた回転）をスキップすれば、ビルボードができる&lt;/li&gt;
&lt;li&gt;Unityは左手系座標だが、 &lt;strong&gt;View空間では右手系座標&lt;/strong&gt; なので、View変換をスキップするときには自前でZの符号を反転する必要がある&lt;/li&gt;
&lt;li&gt;Y軸のビルボードが必要なら、View行列から回転行列のY軸成分のみを抽出した行列を作れば良い&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;シェーダーで実装するメリット&#34;&gt;シェーダーで実装するメリット&lt;/h1&gt;

&lt;p&gt;シェーダーでビルボードを計算するメリットはたくさんあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VRChatなどユーザのC#スクリプトが使えない環境でも動作する&lt;/li&gt;
&lt;li&gt;シーンビュー上でも動作する&lt;/li&gt;
&lt;li&gt;GPU（頂点シェーダー）でビルボード計算ができる

&lt;ul&gt;
&lt;li&gt;ビルボード計算のためのCPU負荷が全くかからない&lt;/li&gt;
&lt;li&gt;板ポリの頂点数は4なので、頂点シェーダーで多少重い処理をしても、GPU負荷への影響はわずか&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;シェーダーのコード-全体&#34;&gt;シェーダーのコード（全体）&lt;/h1&gt;

&lt;p&gt;最終的なシェーダーのコードはこちらです。&lt;/p&gt;

&lt;p&gt;単体で動作しますので、コピペしてお使いいただけます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Unity Y-Axis Billboard Shader by @gam0022
// https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/
Shader &amp;quot;Unlit/Billboard&amp;quot;
{
    Properties
    {
        _MainTex (&amp;quot;Texture&amp;quot;, 2D) = &amp;quot;white&amp;quot; {}
        [KeywordEnum(OFF, ALL_AXIS, Y_AXIS)] _BILLBOARD(&amp;quot;Billboard Mode&amp;quot;, Float) = 2
        _Cutoff (&amp;quot;Alpha Cutoff&amp;quot;, Range(0, 1)) = 0.5
    }
    SubShader
    {
        Tags{ &amp;quot;Queue&amp;quot; = &amp;quot;AlphaTest&amp;quot; &amp;quot;RenderType&amp;quot; = &amp;quot;TransparentCutout&amp;quot;
                &amp;quot;IgnoreProjector&amp;quot; = &amp;quot;True&amp;quot; &amp;quot;DisableBatching&amp;quot; = &amp;quot;True&amp;quot; }

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog

            #include &amp;quot;UnityCG.cginc&amp;quot;
            #pragma multi_compile _BILLBOARD_OFF _BILLBOARD_ALL_AXIS _BILLBOARD_Y_AXIS

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                UNITY_FOG_COORDS(1)
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            
            float _Cutoff;

            v2f vert (appdata v)
            {
                v2f o;

                #if _BILLBOARD_OFF
                {
                    // ビルボードなしの通常の座標変換
                    o.vertex = UnityObjectToClipPos(v.vertex);
                }
                #elif _BILLBOARD_ALL_AXIS
                {                   
                    // Meshの原点をModelView変換
                    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
                    
                    // スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
                    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);
                    
                    // scaleRotatePosを右手系に変換して、viewPosに加算
                    // 本来はView変換で暗黙的にZが反転されているので、
                    // View変換をスキップする場合は明示的にZを反転する必要がある
                    viewPos += float3(scaleRotatePos.xy, -scaleRotatePos.z);
                    
                    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
                }
                #elif _BILLBOARD_Y_AXIS
                {
                    // Meshの原点をModelView変換
                    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
                    
                    // スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
                    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);                
                    
                    // View行列から回転行列のY軸成分のみを抽出
                    float3x3 ViewRotateY = float3x3(
                        1, UNITY_MATRIX_V._m01, 0,
                        0, UNITY_MATRIX_V._m11, 0,
                        0, UNITY_MATRIX_V._m21, -1// Zの符号を反転して右手系に変換
                    );
                    viewPos += mul(ViewRotateY, scaleRotatePos);
                    
                    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
                }
                #endif

                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = tex2D(_MainTex, i.uv);
                clip(col.a - _Cutoff);
                
                // apply fog
                UNITY_APPLY_FOG(i.fogCoord, col);
                return col;
            }
            ENDCG
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h2 id=&#34;ビルボードのモードについて&#34;&gt;ビルボードのモードについて&lt;/h2&gt;

&lt;p&gt;このようにビルボードのモードをインスペクタで選択できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/shader_inspector.png&#34; alt=&#34;シェーダーのインスペクタ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;それぞれの結果を並べました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;OFF: ビルボードなし&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;ALL_AXIS: 通常のビルボード&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Y_AXIS: Y軸のビルボード&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_off.gif&#34; alt=&#34;ビルボードなし&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_all_axis.gif&#34; alt=&#34;ビルボードあり&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_y_axis.gif&#34; alt=&#34;Y軸ビルボード&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;通常の描画&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上から見たときの違和感が大きい&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上から見たときの違和感を緩和できる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;コードの解説&#34;&gt;コードの解説&lt;/h1&gt;

&lt;p&gt;ここから、本題であるシェーダーの解説を行います。&lt;/p&gt;

&lt;h2 id=&#34;通常のビルボード&#34;&gt;通常のビルボード&lt;/h2&gt;

&lt;p&gt;通常のビルボードの頂点シェーダーの処理を抜粋しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#elif _BILLBOARD_ALL_AXIS
{                   
    // ①Meshの原点をModelView変換
    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
    
    // ②スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);
    
    // ③scaleRotatePosを右手系に変換して、viewPosに加算
    // 本来はView変換で暗黙的にZが反転されているので、
    // View変換をスキップする場合は明示的にZを反転する必要がある
    viewPos += float3(scaleRotatePos.xy, -scaleRotatePos.z);
    
    // ④最後にプロジェクション変換
    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;①について&#34;&gt;①について&lt;/h3&gt;

&lt;p&gt;記事の冒頭で&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.頂点シェーダーでView行列の回転（カメラに応じた回転）をスキップすれば、ビルボードができる&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書きましたが、厳密にはMeshの原点だけはView変換を行います。&lt;/p&gt;

&lt;p&gt;原点は回転の影響を受けないので、普通にModelView変換することで平行移動のみ適応できます。&lt;/p&gt;

&lt;h3 id=&#34;②について&#34;&gt;②について&lt;/h3&gt;

&lt;p&gt;Model行列よる平行移動は①で処理しているので、スケールと回転だけを各頂点に適応します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(float3x3)unity_ObjectToWorld&lt;/code&gt; のように &lt;code&gt;float3x3&lt;/code&gt; でキャストすることで、平行移動の行列の成分を捨てることができます。&lt;/p&gt;

&lt;p&gt;列ベクトルの場合は4行目に平行移動の情報が入っていますが、キャストによって4列目の成分が消えるため、平行移動の成分が消えます。&lt;/p&gt;

&lt;h3 id=&#34;③について&#34;&gt;③について&lt;/h3&gt;

&lt;p&gt;①で&lt;code&gt;viewPos&lt;/code&gt; には原点のView空間の座標を代入しましたが、これに②で生成した各頂点の座標を加算しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;float3(scaleRotatePos.xy, -scaleRotatePos.z)&lt;/code&gt; のようにZ成分だけ符号を反転しているのは、冒頭の&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.Unityは左手系座標だが、 &lt;strong&gt;View空間では右手系座標&lt;/strong&gt; なので、View変換をスキップするときには自前でZの符号を反転する必要がある&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;という理由によるものです。&lt;/p&gt;

&lt;p&gt;左手系座標ではZ軸とカメラのforwardベクトルが同じ向きですが、右手系座標では反対向きになります。&lt;/p&gt;

&lt;p&gt;私はこのUnityの仕様を知らずに、かなり悩んでしまいました…&lt;/p&gt;

&lt;p&gt;私がネットで見つけたUnityのビルボードのシェーダーの実装のほとんどはZを反転する処理が抜けていました。
そのため、Box等の厚みのあるMeshに用いると、Cullingが反転して背面ポリゴンが描画される不具合がありました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Z反転なし&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Z反転あり&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/z_reverse_off.png&#34; alt=&#34;Z反転なし&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/z_reverse_on.png&#34; alt=&#34;Z反転あり&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;NG: Cullingが反転して背面ポリゴンが描画されている&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;OK: 正常に表面ポリゴンが描画されている&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;④について&#34;&gt;④について&lt;/h3&gt;

&lt;p&gt;View座標にプロジェクション行列を乗算すると、最終的なクリッピング座標を計算できます（定形処理）。&lt;/p&gt;

&lt;h2 id=&#34;y軸のビルボード&#34;&gt;Y軸のビルボード&lt;/h2&gt;

&lt;p&gt;Y軸のビルボードの頂点シェーダーの処理を抜粋しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#elif _BILLBOARD_Y_AXIS
{
    // ①Meshの原点をModelView変換
    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
    
    // ②スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);                
    
    // ③View行列からY軸の回転だけ抽出した行列を生成
    float3x3 ViewRotateY = float3x3(
        1, UNITY_MATRIX_V._m01, 0,
        0, UNITY_MATRIX_V._m11, 0,
        0, UNITY_MATRIX_V._m21, -1// Zの符号を反転して右手系に変換
    );
    viewPos += mul(ViewRotateY, scaleRotatePos);
    
    // ④最後にプロジェクション変換
    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;①②④について&#34;&gt;①②④について&lt;/h3&gt;

&lt;p&gt;①②④については、通常のビルボードと全く同じ処理なので、説明を割愛します。&lt;/p&gt;

&lt;h3 id=&#34;③について-1&#34;&gt;③について&lt;/h3&gt;

&lt;p&gt;③の &lt;code&gt;ViewRotateY&lt;/code&gt; は冒頭で説明したこの行列です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;3.Y軸のビルボードが必要なら、View行列から回転行列のY軸成分のみを抽出した行列を作れば良い&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;View行列から回転行列のY軸成分だけ抽出して、X軸とZ軸は変換しないようにしています。&lt;/p&gt;

&lt;p&gt;通常のビルボードと同様に、View空間では右手系座標とするために、3行3列目には -1 を指定しています。&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;ビルボードくらいサクッと実装できると思いきや、View空間が右手系座標になっているとは夢にも思わず、すこし苦戦しました。&lt;/p&gt;

&lt;p&gt;そこで動作原理を解説した日本語の記事を探したものの、ほとんど見当たらなかったため、今回筆を執った次第です。&lt;/p&gt;

&lt;p&gt;なるべく丁寧に解説したつもりでしたが、分かりにくい点や間違いがあればコメントやTwitterで教えてください。&lt;/p&gt;

&lt;p&gt;ちなみに今回の方法だとドローコールバッチングができないため、次回はドローコールを減らす解決策を紹介するかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;参考資料&#34;&gt;参考資料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Unity公式リファレンス

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual//SL-BuiltinFunctions.html&#34;&gt;ビルトインシェーダーヘルパー機能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/SL-UnityShaderVariables.html&#34;&gt;ビルトインのシェーダー変数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Camera-worldToCameraMatrix.html&#34;&gt;Camera.worldToCameraMatrix&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ポイント: Note that camera space matches OpenGL convention: camera&amp;rsquo;s forward is the negative Z axis. This is different from Unity&amp;rsquo;s convention, where forward is the positive Z axis.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://edom18.hateblo.jp/entry/2019/01/04/153205&#34;&gt;Unityの行列の扱いとベクトルのオーダー周りについてまとめておく&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ポイント: UnityのC#は「列オーダー」。でもシェーダは「行オーダー」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://logicalbeat.jp/blog/929/&#34;&gt;【Unity】【数学】Unityでのビュー＆プロジェクション行列とプラットフォームの関係&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ポイント: UnityのScene上は左手座標系が原則だが、シェーダ内の行列（UNITY_MATRIX_V）では右手座標系になっているという情報がある。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://marupeke296.com/DXG_No72_ViewProjInfo.html&#34;&gt;その72 ビュー・射影変換行列が持つ情報を抜き出そう&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Model行列・View行列・Projection行列の各成分が何だったか忘れたときに参考になります&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;既存のビルボードのシェーダー実装

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/kaiware007/8ebad2d28638ff83b6b74970a4f70c9a#file-billboard-shader-L47-L50&#34;&gt;Simple Billboard shader for Unity&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;NOTE: Cullingの不具合あり&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/Unity3D/comments/ahqbod/a_billboard_sprite_shader_in_only_one_axis/eeieb6q/&#34;&gt;A billboard sprite shader in only one axis&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;NOTE: 逆行列（転置行列）でViewのXZの回転を打ち消すアプローチなので、計算に無駄がある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;利用したテクスチャ素材

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pngall.com/tree-png/download/23754&#34;&gt;Tree PNG Clipart Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.deviantart.com/fabooguy/art/Dirt-Ground-Texture-Tileable-2048x2048-441212191&#34;&gt;Dirt/Ground Texture [Tileable | 2048x2048]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
