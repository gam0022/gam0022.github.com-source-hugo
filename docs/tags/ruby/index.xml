<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gam0022.net</title>
    <link>https://gam0022.net/tags/ruby/index.xml</link>
    <description>Recent content on gam0022.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <copyright>&amp;copy; 2016 gam0022</copyright>
    <atom:link href="/tags/ruby/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>KLab社内勉強会 ALM で発表しました</title>
      <link>https://gam0022.net/blog/2014/08/03/klab-alm/</link>
      <pubDate>Sun, 03 Aug 2014 11:10:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2014/08/03/klab-alm/</guid>
      <description>&lt;p&gt;KLab の社内勉強会 ALM で LT をしました。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/37458922&#34; width=&#34;427&#34; height=&#34;356&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;https://www.slideshare.net/shohosoda9/immutable-list-gem-klab-alm&#34; title=&#34;Immutable List Gem (KLab ALM版)&#34; target=&#34;_blank&#34;&gt;Immutable List Gem (KLab ALM版)&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;http://www.slideshare.net/shohosoda9&#34; target=&#34;_blank&#34;&gt;Sho Hosoda&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;内容としては、もう2回くらいLTをしている、immutable list gem についての話をしました。&lt;/p&gt;

&lt;p&gt;前回からの違いとしては、クイックソートのベンチマーク結果を盛り込んで、実用性をアピールした内容にしました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>EnumeratorとEnumerator::Lazyの違い</title>
      <link>https://gam0022.net/blog/2014/05/08/enumerator-and-enumerator-lazy/</link>
      <pubDate>Thu, 08 May 2014 08:51:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2014/05/08/enumerator-and-enumerator-lazy/</guid>
      <description>

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Ruby 2.0では、&lt;code&gt;Enumerable#lazy&lt;/code&gt; というメソッドと、その返り値である &lt;code&gt;Enumerator::Lazy&lt;/code&gt; が導入されました。&lt;/p&gt;

&lt;p&gt;この記事では、&lt;code&gt;Enumerable#lazy&lt;/code&gt; と &lt;code&gt;Enumerator::Lazy&lt;/code&gt; によって無限リストをmapできることを紹介します。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;Enumerator&lt;/code&gt; と &lt;code&gt;Enumerator::Lazy&lt;/code&gt; の本質的な違いを説明します。&lt;/p&gt;

&lt;!-- エニュメラブル, エニュメレーター --&gt;

&lt;h1 id=&#34;遅延リストとは&#34;&gt;遅延リストとは&lt;/h1&gt;

&lt;p&gt;遅延リストですが、Haskell などの一部の関数型言語では一般的に使われているもので、
遅延評価といって、値が必要になるまで計算しないことによって、無限に続くリストも扱うことができるというものです。&lt;/p&gt;

&lt;h1 id=&#34;無限リストをmapする&#34;&gt;無限リストをmapする&lt;/h1&gt;

&lt;h2 id=&#34;普通にやってみるとダメ&#34;&gt;普通にやってみるとダメ&lt;/h2&gt;

&lt;p&gt;次のような無限リスト(無限の長さを持つ &lt;code&gt;Range&lt;/code&gt; オブジェクト )を &lt;code&gt;map&lt;/code&gt; する式[1]を考えてみます。&lt;/p&gt;

&lt;p&gt;この式は実行が終わりません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[1] pry(main)&amp;gt; (1..Float::INFINITY).map{|n| n*2}.first(5)
# =&amp;gt; (実行が終わらない...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[1]の式の&lt;code&gt;map&lt;/code&gt; では、&lt;code&gt;Enumerable#map&lt;/code&gt; が呼ばれます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enumerable#map&lt;/code&gt; は配列&lt;code&gt;Array&lt;/code&gt;を返り値とするメソッドなので、無限の長さの配列を作ろうとして、処理が終わらなくなります。&lt;/p&gt;

&lt;h2 id=&#34;lazy-を付けてみると動く&#34;&gt;lazy を付けてみると動く&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Enumerable#lazy&lt;/code&gt; を使って、次の式[2]ように無限リストを &lt;code&gt;map&lt;/code&gt; によって処理することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[2] pry(main)&amp;gt; (1..Float::INFINITY).lazy.map{|n| n*2}.first(5)
# =&amp;gt; [2, 4, 6, 8, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[2]の式の&lt;code&gt;map&lt;/code&gt; では、&lt;code&gt;Enumerator::Lazy#map&lt;/code&gt; が呼ばれます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enumerable#lazy&lt;/code&gt; は リスト(Array,Rangeなど)を 遅延リスト &lt;code&gt;Enumerator::Lazy&lt;/code&gt; に変換するメソッドです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enumerator::Lazy#map&lt;/code&gt; も &lt;code&gt;Enumerator::Lazy&lt;/code&gt; を返すメソッドです。&lt;/p&gt;

&lt;p&gt;したがって、&lt;code&gt;(1..Float::INFINITY).lazy.map{|n| n*2}&lt;/code&gt; 全体が &lt;code&gt;Enumerator::Lazy&lt;/code&gt; になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enumerator::Lazy&lt;/code&gt; の中身は、&lt;code&gt;force(to_a)&lt;/code&gt;や&lt;code&gt;first&lt;/code&gt;が呼ばれるまでは、値は評価されません。&lt;/p&gt;

&lt;p&gt;最後に &lt;code&gt;Enumerator::Lazy#first&lt;/code&gt; が呼ばれた時に、ようやく値を評価するので、無限リストを扱うことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;enumerable-map-と-enumerator-lazy-map&#34;&gt;Enumerable#map と Enumerator::Lazy#map&lt;/h2&gt;

&lt;p&gt;ここで注目するべきポイントは、[1]と[2]の &lt;code&gt;map&lt;/code&gt; は全く別のメソッドで、定義されている場所も返り値も異なっていることです。&lt;/p&gt;

&lt;p&gt;特に、[2]では、結果を即座に配列にしないで、遅延リストとして保持しているという点が重要です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[1]のmap: &lt;code&gt;Enumerable#map&lt;/code&gt; -&amp;gt; &lt;code&gt;Array&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[2]のmap: &lt;code&gt;Enumerator::Lazy#map&lt;/code&gt; -&amp;gt; &lt;code&gt;Enumerator::Lazy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;enumerator-も遅延リスト&#34;&gt;Enumerator も遅延リスト&lt;/h1&gt;

&lt;p&gt;Ruby2.0 から新しく遅延リストが登場したかのように誤解してしまうかもしれませんが、古くからRubyには&lt;code&gt;Enumerator&lt;/code&gt;というクラスがあります。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;IO#each_line&lt;/code&gt; はブロックを省略すると、ファイルの各行を順に &lt;code&gt;yield&lt;/code&gt; するような &lt;code&gt;Enumerator&lt;/code&gt; を返します。&lt;/p&gt;

&lt;p&gt;次のような例では、ファイルを全て読み込まずに、最初の10行だけを処理することができます。
つまり、&lt;code&gt;IO#each_line&lt;/code&gt; はファイル全てを読み込みません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open(&amp;quot;log.txt&amp;quot;) do |f|
  puts f.each_line.first(10)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;驚くかもしれませんが、&lt;code&gt;Enumerator::Lazy&lt;/code&gt; と &lt;code&gt;Enumerator&lt;/code&gt; はどちらも遅延リストです。&lt;/p&gt;

&lt;p&gt;すこし工夫すれば、&lt;code&gt;Enumerator&lt;/code&gt; でも無限リストを処理することもできます。これは最初の例と全く同じ結果になります。
つまり、&lt;code&gt;Enumerator&lt;/code&gt; でも無限リストを処理できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Enumerator.new{|y|
  (1..Float::INFINITY).each{|n|
    y &amp;lt;&amp;lt; n*2
  }
}.first(5) # =&amp;gt; [2, 4, 6, 8, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、&lt;code&gt;Enumerator&lt;/code&gt; でも無限リストを処理することもできますが、&lt;code&gt;Enumerator::Lazy&lt;/code&gt; を使ったほうが、
map によって直感的で読みやすく短いコードで表現できます。&lt;/p&gt;

&lt;h1 id=&#34;enumerator-lazy-の真の目的&#34;&gt;Enumerator::Lazy の真の目的&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Enumerator::Lazy&lt;/code&gt; と &lt;code&gt;Enumerator&lt;/code&gt; の 2つのクラスの本質的な違いは、
メソッドチェーンで呼び出される &lt;code&gt;map&lt;/code&gt; が &lt;code&gt;Array&lt;/code&gt; を返すか、&lt;code&gt;Enumerator::Lazy&lt;/code&gt; を返すかどうかにあります。&lt;/p&gt;

&lt;p&gt;2つのクラス自体の機能としては、ほとんど違いはありません。&lt;/p&gt;

&lt;p&gt;言い方を変えれば、&lt;code&gt;Enumerator::Lazy&lt;/code&gt; の真の目的は lazy版の&lt;code&gt;map&lt;/code&gt; や &lt;code&gt;select&lt;/code&gt; を再定義することにあります。&lt;/p&gt;

&lt;h1 id=&#34;lazyを付けるとmapの動作が変わる不思議な仕様&#34;&gt;lazyを付けるとmapの動作が変わる不思議な仕様&lt;/h1&gt;

&lt;p&gt;なぜ、lazy を付けると map や select の動作が変わる不思議な動作にしたのか？ と疑問に思った人もいると思います。&lt;/p&gt;

&lt;p&gt;Enumerable#lazy を作った &lt;a href=&#34;https://bugs.ruby-lang.org/issues/4890&#34;&gt;Yutaka HARA&lt;/a&gt; さんが、&lt;a href=&#34;http://magazine.rubyist.net/?0041-200Special-lazy&#34;&gt;るびま&lt;/a&gt;で答えていました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Enumerable&lt;/code&gt; モジュールには、lazy 版がほしくなるようなメソッドが &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;select&lt;/code&gt;、&lt;code&gt;reject&lt;/code&gt;、&lt;code&gt;drop&lt;/code&gt;、&amp;hellip; とたくさんある。&lt;/li&gt;
&lt;li&gt;全部追加すると、&lt;code&gt;Enumerable&lt;/code&gt; モジュールのメソッドが増えすぎる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enumerator::Lazy&lt;/code&gt; 名前空間を提供することによって、「lazy」という メソッド名をひとつ追加するだけで lazy 版の &lt;code&gt;map&lt;/code&gt; や &lt;code&gt;select&lt;/code&gt; などが使えるようにした。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;リンク先の記事でも、&lt;code&gt;Enumerable#lazy&lt;/code&gt;は「&lt;code&gt;map&lt;/code&gt; や &lt;code&gt;select&lt;/code&gt; などの lazy 版を提供するための名前空間を提供するメソッド」というのがより正確な説明になると述べられています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;遅延リストによって、無限リストなどをシンプルに扱うことができる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enumerator::Lazy&lt;/code&gt; と &lt;code&gt;Enumerator&lt;/code&gt; の本質的な違いは、&lt;code&gt;map&lt;/code&gt; や &lt;code&gt;select&lt;/code&gt; などのメソッドの挙動の違いにある&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enumerator::Lazy&lt;/code&gt; の真の目的は lazy版の &lt;code&gt;map&lt;/code&gt; や &lt;code&gt;select&lt;/code&gt; を再定義すること&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;補足&#34;&gt;補足&lt;/h1&gt;

&lt;h2 id=&#34;クラスの継承関係&#34;&gt;クラスの継承関係&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Enumerator::Lazy&lt;/code&gt;や&lt;code&gt;Enumerator&lt;/code&gt;、&lt;code&gt;Enumerable&lt;/code&gt;などの継承関係が複雑なので、図にまとめました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2014-05-08-enumerator-and-enumerator-lazy.png&#34; alt=&#34;600 クラスの継承関係&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;遅延リストが使える場面&#34;&gt;遅延リストが使える場面&lt;/h2&gt;

&lt;p&gt;最後に遅延リストが有効に使える場面を考えてみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数学的に無限長の数列を扱いたい&lt;/li&gt;
&lt;li&gt;TwitterのTimeLine&lt;/li&gt;
&lt;li&gt;巨大なファイル(の一部だけ処理したい)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に、数学的な処理には強力だと思います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; や &lt;code&gt;first&lt;/code&gt; メソッドを使って、数列の長さを気にせずに、各処理を抽象化できるのが強力だと思います。&lt;/p&gt;

&lt;h1 id=&#34;qiita-もやってます&#34;&gt;Qiita もやってます&lt;/h1&gt;

&lt;p&gt;同じ内容の記事を &lt;a href=&#34;http://qiita.com/gam0022/items/8acfc0c674b96060c03f&#34;&gt;Qiita&lt;/a&gt; にも投稿しました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby 2.1.0 を自力でビルドする</title>
      <link>https://gam0022.net/blog/2013/12/27/try-ruby-2-1-0/</link>
      <pubDate>Fri, 27 Dec 2013 20:16:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/12/27/try-ruby-2-1-0/</guid>
      <description>&lt;h1 id=&#34;ruby-2-1-0-がリリース&#34;&gt;Ruby 2.1.0 がリリース&lt;/h1&gt;

&lt;p&gt;Ruby 2.1.0 がついにリリースされましたね！！！&lt;/p&gt;

&lt;p&gt;なんと嬉しいクリスマスプレゼントなんでしょう！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruby-lang.org/en/news/2013/12/25/ruby-2-1-0-is-released/&#34;&gt;Ruby 2.1.0 is released&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ruby-lang.org/ja/news/2013/12/25/ruby-2-1-0-is-released/&#34;&gt;Ruby 2.1.0 リリース&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;早速-試してみる&#34;&gt;早速、試してみる&lt;/h1&gt;

&lt;p&gt;MBAを買い替えた時に、Rubyのバージョン管理システムを&lt;code&gt;rvm&lt;/code&gt;から&lt;code&gt;rbenv&lt;/code&gt;に乗り換えました。&lt;/p&gt;

&lt;p&gt;というわけで、&lt;code&gt;rbenv(ruby-build)&lt;/code&gt; で Ruby を入れようと思いました。&lt;/p&gt;

&lt;p&gt;ruby-build で Ruby 2.1.0 をインストール!?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~/Downloads]$ brew upgrade ruby-build
Error: ruby-build-20131220.1 already installed
[~/Downloads]$ rbenv install -l
Available versions:
  1.8.6-p383
  1.8.6-p420
  1.8.7-p249
  1.8.7-p302
  1.8.7-p334
  1.8.7-p352
  1.8.7-p357
  1.8.7-p358
  1.8.7-p370
  1.8.7-p371
  1.8.7-p374
  1.9.1-p378
  1.9.1-p430
  1.9.2-p0
  1.9.2-p180
  1.9.2-p290
  1.9.2-p318
  1.9.2-p320
  1.9.3-dev
  1.9.3-p0
  1.9.3-p125
  1.9.3-p194
  1.9.3-p286
  1.9.3-p327
  1.9.3-p362
  1.9.3-p374
  1.9.3-p385
  1.9.3-p392
  1.9.3-p429
  1.9.3-p448
  1.9.3-p484
  1.9.3-preview1
  1.9.3-rc1
  2.0.0-dev
  2.0.0-p0
  2.0.0-p195
  2.0.0-p247
  2.0.0-p353
  2.0.0-preview1
  2.0.0-preview2
  2.0.0-rc1
  2.0.0-rc2
  2.1.0-dev
  2.1.0-preview1
  2.1.0-preview2
  2.1.0-rc1
  heroku-1.8.7-p375
  jruby-1.5.6
  jruby-1.6.3
  jruby-1.6.4
  jruby-1.6.5
  jruby-1.6.5.1
  jruby-1.6.6
  jruby-1.6.7
  jruby-1.6.7.2
  jruby-1.6.8
  jruby-1.7.0
  jruby-1.7.0-preview1
  jruby-1.7.0-preview2
  jruby-1.7.0-rc1
  jruby-1.7.0-rc2
  jruby-1.7.1
  jruby-1.7.2
  jruby-1.7.3
  jruby-1.7.4
  jruby-1.7.5
  jruby-1.7.6
  jruby-1.7.7
  jruby-1.7.8
  jruby-1.7.9
  maglev-1.0.0
  maglev-1.1.0-dev
  maglev-2.0.0-dev
  mruby-dev
  rbx-1.2.4
  rbx-2.0.0
  rbx-2.0.0-dev
  rbx-2.0.0-rc1
  rbx-2.1.0
  rbx-2.1.1
  rbx-2.2.0
  rbx-2.2.1
  ree-1.8.6-2009.06
  ree-1.8.7-2009.09
  ree-1.8.7-2009.10
  ree-1.8.7-2010.01
  ree-1.8.7-2010.02
  ree-1.8.7-2011.03
  ree-1.8.7-2011.12
  ree-1.8.7-2012.01
  ree-1.8.7-2012.02
  topaz-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんと、2.1.0 が無いotz&lt;/p&gt;

&lt;h1 id=&#34;自力でビルド&#34;&gt;自力でビルド&lt;/h1&gt;

&lt;p&gt;仕方がないので、ソースコードから自力でビルドします。&lt;/p&gt;

&lt;h2 id=&#34;ソースコードをダウンロード&#34;&gt;ソースコードをダウンロード&lt;/h2&gt;

&lt;p&gt;GitHub などから clone しても良いですが、今回は公式ページにあるURLからソースコードを入手します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~/tmp]$ wget http://cache.ruby-lang.org/pub/ruby/2.1/ruby-2.1.0.tar.bz2 .
[~/tmp]$ tar zxvf ruby-2.1.0.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ビルドする&#34;&gt;ビルドする&lt;/h2&gt;

&lt;p&gt;まあ普通にビルドします。&lt;/p&gt;

&lt;p&gt;今回はちょっと試してみるだけなので、インストール先を &lt;code&gt;/Users/gam0022/ruby-2.1.0/&lt;/code&gt; にしてみました。&lt;/p&gt;

&lt;p&gt;イントール先は、&lt;code&gt;./configure --prefix={絶対パス}&lt;/code&gt;のようにやると良いです。&lt;/p&gt;

&lt;p&gt;存在しないパスを指定すると、勝手にディレクトリを作ってくれるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~/tmp]$ cd ruby-2.1.0
[~/tmp/ruby-2.1.0]$ autoconf
[~/tmp/ruby-2.1.0]$ ./configure --prefix=/Users/gam0022/ruby-2.1.0/
[~/tmp/ruby-2.1.0]$ make
[~/tmp/ruby-2.1.0]$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;とりあえず、バージョンを確認してみます。お、ちゃんと2.1.0になってますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~/tmp/ruby-2.1.0]$ cd ~/ruby-2.1.0
[~/ruby-2.1.0/bin]$ ./ruby -v
ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-darwin13.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;irb&lt;/code&gt;で確認すると、2.1.0 から導入された 分数と虚数のリテラルもちゃんと使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~/ruby-2.1.0/bin]$ ./irb
irb(main):001:0&amp;gt; 1/3r
=&amp;gt; (1/3)
irb(main):002:0&amp;gt; 42i
=&amp;gt; (0+42i)
irb(main):003:0&amp;gt; exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RGenGCなど、他にも気になる変更はたくさんあるので、色々と実験してみたいですね!!&lt;/p&gt;

&lt;h1 id=&#34;追記-ruby-build-を-github-から-clone-して最新にする&#34;&gt;追記: ruby-build を GitHub から clone して最新にする&lt;/h1&gt;

&lt;p&gt;ruby-build が Ruby最新版に対応してないのは良くあることのようです。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://9ensan.com/blog/programming/ruby/rbenv-plugins-ruby-build/&#34;&gt;rbenvで最新のRubyがインストール出来ない時の対処&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ruby-build の最新版を GitHub から clone することで解決しました。&lt;/p&gt;

&lt;p&gt;upgrade-ruby-build&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~]$ brew uninstall ruby-build
Uninstalling /usr/local/Cellar/ruby-build/20131220.1...
[~]$ git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
Cloning into &#39;/Users/gam0022/.rbenv/plugins/ruby-build&#39;...
remote: Reusing existing pack: 2715, done.
remote: Counting objects: 47, done.
remote: Compressing objects: 100% (37/37), done.
remote: Total 2762 (delta 22), reused 27 (delta 3)
Receiving objects: 100% (2762/2762), 468.96 KiB | 98.00 KiB/s, done.
Resolving deltas: 100% (1191/1191), done.
Checking connectivity... done
[~]$ rbenv install -l
Available versions:
  1.8.6-p383
  1.8.6-p420
  1.8.7-p249
  1.8.7-p302
  1.8.7-p334
  1.8.7-p352
  1.8.7-p357
  1.8.7-p358
  1.8.7-p370
  1.8.7-p371
  1.8.7-p374
  1.8.7-p375
  1.9.1-p378
  1.9.1-p430
  1.9.2-p0
  1.9.2-p180
  1.9.2-p290
  1.9.2-p318
  1.9.2-p320
  1.9.2-p326
  1.9.3-dev
  1.9.3-p0
  1.9.3-p125
  1.9.3-p194
  1.9.3-p286
  1.9.3-p327
  1.9.3-p362
  1.9.3-p374
  1.9.3-p385
  1.9.3-p392
  1.9.3-p429
  1.9.3-p448
  1.9.3-p484
  1.9.3-preview1
  1.9.3-rc1
  2.0.0-dev
  2.0.0-p0
  2.0.0-p195
  2.0.0-p247
  2.0.0-p353
  2.0.0-preview1
  2.0.0-preview2
  2.0.0-rc1
  2.0.0-rc2
  2.1.0
  2.1.0-dev
  2.1.0-preview1
  2.1.0-preview2
  2.1.0-rc1
  2.2.0-dev
  jruby-1.5.6
  jruby-1.6.3
  jruby-1.6.4
  jruby-1.6.5
  jruby-1.6.5.1
  jruby-1.6.6
  jruby-1.6.7
  jruby-1.6.7.2
  jruby-1.6.8
  jruby-1.7.0
  jruby-1.7.0-preview1
  jruby-1.7.0-preview2
  jruby-1.7.0-rc1
  jruby-1.7.0-rc2
  jruby-1.7.1
  jruby-1.7.2
  jruby-1.7.3
  jruby-1.7.4
  jruby-1.7.5
  jruby-1.7.6
  jruby-1.7.7
  jruby-1.7.8
  jruby-1.7.9
  maglev-1.0.0
  maglev-1.1.0-dev
  maglev-2.0.0-dev
  mruby-dev
  rbx-1.2.4
  rbx-2.0.0
  rbx-2.0.0-dev
  rbx-2.0.0-rc1
  rbx-2.1.0
  rbx-2.1.1
  rbx-2.2.0
  rbx-2.2.1
  rbx-2.2.2
  ree-1.8.6-2009.06
  ree-1.8.7-2009.09
  ree-1.8.7-2009.10
  ree-1.8.7-2010.01
  ree-1.8.7-2010.02
  ree-1.8.7-2011.03
  ree-1.8.7-2011.12
  ree-1.8.7-2012.01
  ree-1.8.7-2012.02
  topaz-dev
[~]$ rbenv install 2.1.0
Downloading ruby-2.1.0.tar.gz...
-&amp;gt; http://dqw8nmjcqpjn7.cloudfront.net/9e6386d53f5200a3e7069107405b93f7
Installing ruby-2.1.0...
^@^@^@Installed ruby-2.1.0 to /Users/gam0022/.rbenv/versions/2.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無事に、rbenv から 2.1.0 をインストールできました!!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rbenv-versions&lt;/code&gt;でカレントのrubyのバージョンを確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~]$ rbenv versions
  system
  1.9.3-p484
* 2.0.0-p353 (set by /Users/gam0022/.rbenv/version)
  2.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;今後-ruby-build-をアップデートする方法&#34;&gt;今後、ruby-build をアップデートする方法&lt;/h2&gt;

&lt;p&gt;今後、ruby-build をアップデートしたくなったらこうします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.rbenv/plugins/ruby-build
git pull
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ruby-build が homebrew の Formula への反映するのが遅いみたいですね。最新のRubyを使いたくて待ちきれないような方はどうぞ。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rubyのgemのメモ</title>
      <link>https://gam0022.net/blog/2013/12/26/gem-memo/</link>
      <pubDate>Thu, 26 Dec 2013 10:46:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/12/26/gem-memo/</guid>
      <description>

&lt;p&gt;gem関連に関してメモを残します。&lt;/p&gt;

&lt;h1 id=&#34;gem-ファイルを展開してパッケージの中身を見る&#34;&gt;.gem ファイルを展開してパッケージの中身を見る&lt;/h1&gt;

&lt;p&gt;.gem ファイルを展開してパッケージの中身を見る方法を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gem unpack&lt;/code&gt;はgemをインストールしたくないけど、単に中身を見たいときなどに役に立ちます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gem unpack xxx.gem&lt;/code&gt; のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~/Downloads]$ gem unpack unicode_math-1.2.0.gem
Unpacked gem: &#39;/Users/gam0022/Downloads/unicode_math-1.2.0&#39;
[~/Downloads]$
[~/Downloads]$ tree unicode_math-1.2.0
unicode_math-1.2.0
├── Gemfile
├── LICENSE.txt
├── README.md
├── Rakefile
├── lib
│   ├── unicode_math
│   │   ├── constants.rb
│   │   ├── division.rb
│   │   ├── exponents.rb
│   │   ├── fractions.rb
│   │   ├── multiplication.rb
│   │   ├── roots.rb
│   │   ├── set.rb
│   │   ├── sigma.rb
│   │   └── trigonometry.rb
│   └── unicode_math.rb
├── spec
│   ├── spec_helper.rb
│   ├── support
│   │   └── random.rb
│   └── unicode_math
│       ├── constants_spec.rb
│       ├── division_spec.rb
│       ├── exponents_spec.rb
│       ├── fractions_spec.rb
│       ├── multiplication_spec.rb
│       ├── root_spec.rb
│       ├── set_spec.rb
│       ├── sigma_spec.rb
│       └── trigonometry_spec.rb
└── unicode_math.gemspec

5 directories, 26 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;gem-ファイルから-gem-をインストールする&#34;&gt;.gem ファイルから gem をインストールする&lt;/h1&gt;

&lt;p&gt;.gem ファイルから gem をインストールする方法を紹介します。&lt;/p&gt;

&lt;p&gt;RubyGems でリンク切れを起こしたgemを無理やりインストールしたいときに使いました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gem install -l xxx.gem&lt;/code&gt; のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[~/Downloads]$ gem install -l unicode_math-1.2.0.gem

Successfully installed unicode_math-1.2.0
Parsing documentation for unicode_math-1.2.0
Installing ri documentation for unicode_math-1.2.0
1 gem installed
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>いろんな言語で Trick or Treat</title>
      <link>https://gam0022.net/blog/2013/10/31/trick-or-treat/</link>
      <pubDate>Thu, 31 Oct 2013 23:59:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/10/31/trick-or-treat/</guid>
      <description>&lt;p&gt;いろんな言語で Trick or Treat してみました。&lt;/p&gt;

&lt;p&gt;Java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if(!treat) trick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C#&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;if(!Treat) Trick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if not treat:
    self.trick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;trick unless treat?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結論: &lt;strong&gt;Ruby が一番シンプル&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;おまけ&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;||&lt;/code&gt; の短絡評価を使えばもっとシンプルに書けます。&lt;/p&gt;

&lt;p&gt;しかし、英語とは Trick と Treat の順番が逆になります。&lt;/p&gt;

&lt;p&gt;C&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;treat || trick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;treat? or trick
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上のような書き方だと、JavaやC#などの言語だと、文だとみなしてくれないのでコンパイルエラーになります。&lt;/p&gt;

&lt;p&gt;仕方ないので代入文にして回避します。&lt;/p&gt;

&lt;p&gt;Java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//treat || trick(); // コンパイルエラー
boolean r = treat || trick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C#&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var r = Treat || Trick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;trick() に副作用があるとしたら、こういう書き方は避けるべきですが、今回はあえて利用しています。
普通はこういうコードを書かないほうがいいと(個人的には)思います。&lt;/p&gt;

&lt;h1 id=&#34;元ネタ&#34;&gt;元ネタ&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p&gt;Java「if(!treat) trick();」&amp;#10; &amp;#10;C# 「if(!Treat) Trick();」&amp;#10; &amp;#10;Python 「&amp;#10;if not treat:&amp;#10; self.trick();」&amp;#10;&amp;#10;Perl「treat or die」&lt;/p&gt;&amp;mdash; らこ (@laco0416) &lt;a href=&#34;https://twitter.com/laco0416/statuses/263596378561855488&#34;&gt;October 31, 2012&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p&gt;Ruby「trick unless treat」&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/statuses/395724005446930432&#34;&gt;October 31, 2013&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;</description>
    </item>
    
    <item>
      <title>Rubyで関数型プログラミングをするための ImmutableList gem を公開</title>
      <link>https://gam0022.net/blog/2013/10/22/immutable-list-gem/</link>
      <pubDate>Tue, 22 Oct 2013 14:17:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/10/22/immutable-list-gem/</guid>
      <description>&lt;h1 id=&#34;immutablelist-gem-とは&#34;&gt;ImmutableList gem とは&lt;/h1&gt;

&lt;p&gt;Immutable な LinkedList を Ruby で使うためのライブラリです。&lt;/p&gt;

&lt;p&gt;C-Extension なので、Rubyで実装したものに比べて動作が高速です。&lt;/p&gt;

&lt;p&gt;Ruby の &lt;code&gt;Array&lt;/code&gt; は 配列で実装されているため、
長いリストでの先頭への要素を追加(&lt;code&gt;cons&lt;/code&gt;)や連結(&lt;code&gt;append&lt;/code&gt;)が
とても遅いという問題を解決しようと思って作りました。&lt;/p&gt;

&lt;p&gt;用途としては、Rubyで再帰を使って関数型言語風にプログラムを組むことを想定しています。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/MjwxdjZX6fPjtf&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/shohosoda9/immutable-list-gem-klab-alm&#34; title=&#34;Immutable List Gem (KLab ALM版)&#34; target=&#34;_blank&#34;&gt;Immutable List Gem (KLab ALM版)&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target=&#34;_blank&#34; href=&#34;//www.slideshare.net/shohosoda9&#34;&gt;Sho Hosoda&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;導入方法&#34;&gt;導入方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://rubygems.org/gems/immutable_list&#34;&gt;RubyGems&lt;/a&gt; で公開したので、次のようにターミナルで入力するだけで導入できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gem install immutable_list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;基本的な使い方&#34;&gt;基本的な使い方&lt;/h1&gt;

&lt;p&gt;基本的には、Ocaml の List のような動作をします。メソッド名も Ocaml を意識しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;immutable_list&#39;

p ImmutableList.new # =&amp;gt; ()

p l1 = ImmutableList.new.cons(1).cons(2).cons(3) # =&amp;gt; (3, 2, 1)
p l1.head # =&amp;gt; 3
p l1.tail # =&amp;gt; (2, 1)

p l2 = ImmutableList[1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;] #=&amp;gt; (1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)

p l1.rev_append(l2) #=&amp;gt; (1, 2, 3, 1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)
p l1.rev #=&amp;gt; (1, 2, 3)
p l3 = l1.append(l2) #=&amp;gt; (3, 2, 1, 1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)

p l3.length # =&amp;gt; 8
p ImmutableList[].length #=&amp;gt; 0

p l3.nth(0) #=&amp;gt; 3
p l3[7] #=&amp;gt; &amp;quot;b&amp;quot;
p l3[100] #=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;rubyで関数型プログラミングを書きたい&#34;&gt;Rubyで関数型プログラミングを書きたい&lt;/h1&gt;

&lt;p&gt;まずここで言う、関数型プログラミングというのは、
一般的な言語がループを使って繰り返しを表現するのに対して、
再帰を使って繰り返しを表現することを指します。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;ImmutableList&lt;/code&gt;を使えば、クイックソートを次のように実装することができます。&lt;/p&gt;

&lt;p&gt;再帰を使うことで、プログラムの本質に関係ないループと変数が消えて、
とても読みやすく短くプログラムを書くことができます。(読みやすさには個人差があります。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;immutable_list&#39;

def partition(a, l, lt, ge)
  if l.empty?
    [lt, ge]
  elsif l.head &amp;lt; a
    partition(a, l.tail, lt.cons(l.head), ge)
  else
    partition(a, l.tail, lt, ge.cons(l.head))
  end
end

def qsort(l)
  if l.empty?
    ImmutableList.new
  else
    lt, ge = partition(l.head, l.tail, ImmutableList.new, ImmutableList.new)
    qsort(lt) + qsort(ge).cons(l.head)
  end
end

l = ImmutableList[3, 5, 8, 1, 4, 7, 10, -3, 2, 100, 43, 10, 50]
p qsort(l) #=&amp;gt; (-3, 1, 2, 3, 4, 5, 7, 8, 10, 10, 43, 50, 100)
&lt;/code&gt;&lt;/pre&gt;

&lt;!--## 補足

なぜ、関数型プログラミングするためには Immutable なリストが必要なのかわからない人に補足です。

もし、リストに破壊的な操作を許してしまうと、再帰の過程で
--&gt;

&lt;h1 id=&#34;動作速度について&#34;&gt;動作速度について&lt;/h1&gt;

&lt;p&gt;C-Extension なので、動作が高速だと言いますが、どのくらい速いのか気になる人もいるかと思います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;と&lt;code&gt;ImmutableList&lt;/code&gt;で、先頭に長さ3のリストを 連結する処理にかかった秒数を、
連結した回数ごとにまとめました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;連結回数&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Array&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;LinkedList&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.5e-05&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.0e-05&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.007251&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00166&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.727542&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.015206&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;100000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;102.080825&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.414083&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;この測定には、&lt;a href=&#34;https://github.com/gam0022/linkedlist/blob/master/benchmark.rb&#34;&gt;benchmark.rb&lt;/a&gt; を用いました。&lt;/p&gt;

&lt;p&gt;リストの長さが長くなるほど、&lt;code&gt;Array&lt;/code&gt;よりも&lt;code&gt;LinkedList&lt;/code&gt; の方が相対的に高速になります。&lt;/p&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;GitHub

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/immutable_list&#34;&gt;https://github.com/gam0022/immutable_list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.loveruby.net/w/RubyExtensionProgrammingGuide.html&#34;&gt;RubyExtensionProgrammingGuide&lt;/a&gt; がとても参考になりました。&lt;/li&gt;
&lt;li&gt;WBなどはしていないので、&lt;a href=&#34;http://www.atdot.net/~ko1/activities/RubyKaigi2013-ko1.pdf&#34;&gt;RGenGC&lt;/a&gt; に対応できてるか不安です。

&lt;ul&gt;
&lt;li&gt;そもそも、どの関数も破壊的ではないので、WBが発生するタイミングが無い?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;セーフレベルやオブジェクトの汚染など、セキュリティのことは全く考えてません。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; や &lt;code&gt;tail&lt;/code&gt; や &lt;code&gt;nth&lt;/code&gt; で要素がない場合ですが、すべて&lt;code&gt;nil&lt;/code&gt;を返すようにして、例外は発生させないことにしました。

&lt;ul&gt;
&lt;li&gt;将来的には例外を発生させるように仕様を変更するかもしれません。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;これまでのあらすじ&#34;&gt;これまでのあらすじ&lt;/h1&gt;

&lt;p&gt;RubyのC-Extentionとして、Immutable な LinkedList を作り、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gam0022.net/blog/2013/08/19/ruby-linkedlist/&#34;&gt;RubyでLinkedListを使うためのC拡張を作った&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RubyGems で C-Extention を含んだGemを作る方法を紹介しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gam0022.net/blog/2013/10/18/gems-with-extensions/&#34;&gt;BundlerでC拡張を含んだgemを公開する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1つ目の記事と内容がほとんど同じですが、クラス名やインストール方法が変わったので、記事を書き直しました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>BundlerでC拡張を含んだgemを公開する</title>
      <link>https://gam0022.net/blog/2013/10/18/gems-with-extensions/</link>
      <pubDate>Fri, 18 Oct 2013 01:22:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/10/18/gems-with-extensions/</guid>
      <description>&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;先日、&lt;a href=&#34;https://rubygems.org/gems/immutable_list&#34;&gt;immutable_list&lt;/a&gt; というgemを公開したのですが、
思っていたよりも簡単に &lt;a href=&#34;https://rubygems.org/gems/immutable_list&#34;&gt;rubygems.org&lt;/a&gt; に登録することができて感動しました。&lt;/p&gt;

&lt;p&gt;gemを作るには、色々な方法があるようですが、最近だとBundler を使う方法が一番シンプルで良さそうです。&lt;/p&gt;

&lt;p&gt;RubyGems に gem を登録するためには、gitのリモートリポジトリが必要ですが、ここでは GitHub を利用します。&lt;/p&gt;

&lt;p&gt;あと、よく質問されるのですが、RubyGems に登録するために審査は一切ありません。&lt;/p&gt;

&lt;h2 id=&#34;tips-gemの命名方法&#34;&gt;Tips: gemの命名方法&lt;/h2&gt;

&lt;p&gt;本題とはズレますが、gemの命名にはルールがあるので軽く紹介します。&lt;/p&gt;

&lt;p&gt;gemname には、小文字のアルファベット、数字、ハイフン、アンダースコア、ドットが使用可能のようです。&lt;/p&gt;

&lt;p&gt;ハイフンとアンダースコアは次のように使い分けることが推奨されています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;- (ハイフン) : パスの区切り&lt;/li&gt;
&lt;li&gt;_ (アンダースコア) : 単語の区切り&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;普通のgemを公開する場合&#34;&gt;普通のgemを公開する場合&lt;/h1&gt;

&lt;p&gt;C拡張を含まない、Rubyで実装したライブラリをgemにする場合は、とても簡単です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://shoprev.hatenablog.com/entry/2013/08/02/205735&#34;&gt;はじめてbundlerでruby gem作ってgithubとrubygemsに上げてみた&lt;/a&gt; という記事が分かりやすかったので、
Rubyで実装したライブラリをgemにする場合はこちらを参考にすれば良いと思います。&lt;/p&gt;

&lt;p&gt;基本的には、次のような流れになります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$ bundle gem &amp;lt;gemname&amp;gt;&lt;/code&gt; でgemを作るために必要なファイルの雛形の一式が作られるので、細かい部分を編集する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ cd &amp;lt;gemname&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/&amp;lt;gemname&amp;gt;.rb&lt;/code&gt; にライブラリの本体を実装する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/&amp;lt;gemname&amp;gt;/version.rb&lt;/code&gt; でバージョンを指定する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;gemname&amp;gt;.gemspec&lt;/code&gt; のTODOを埋める。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gemのパッケージを作成&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ gem build &amp;lt;gemname&amp;gt;.gemspec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ rake install&lt;/code&gt; で動作を念のためにテスト。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GitHub に push&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ファイル一式をGitHubに登録する。(普通のgitのリポジトリを作るのと同じなので詳しい説明は省きます。)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RubyGems に push&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ gem push pkg/&amp;lt;gemname&amp;gt;&amp;gt;-x.x.x.gem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;これで、世界中の誰からでも &lt;code&gt;$ gem install &amp;lt;gemname&amp;gt;&lt;/code&gt; で利用可能になる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;バージョンアップ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib/&amp;lt;gemname&amp;gt;/version.rb&lt;/code&gt; を編集。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ rake release&lt;/code&gt; で RubyGems と GitHub の両方に push してくれる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;削除&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ gem yank &amp;lt;gemname&amp;gt; -v x.x.x&lt;/code&gt; で RubyGems から削除できる。&lt;/li&gt;
&lt;li&gt;履歴は残るので、完全に消すのは中の人にコンタクトするしかないよう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;c拡張を含むgemを公開する場合&#34;&gt;C拡張を含むgemを公開する場合&lt;/h1&gt;

&lt;p&gt;C拡張を含むgemを作りたい場合は、ちょっと面倒です。&lt;/p&gt;

&lt;p&gt;日本語の記事が見つからなかったので、&lt;a href=&#34;http://guides.rubygems.org/gems-with-extensions/&#34;&gt;Gems with Extensions&lt;/a&gt;を参考にして頑張りました。&lt;/p&gt;

&lt;p&gt;ここでは、&lt;code&gt;immutable_list&lt;/code&gt; という gem 名を例にとって、C拡張を含むgemを公開するまでを説明します。&lt;/p&gt;

&lt;h2 id=&#34;1-雛形を作る&#34;&gt;1. 雛形を作る&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle gem immutable_list
      create  immutable_list/Gemfile
      create  immutable_list/Rakefile
      create  immutable_list/LICENSE.txt
      create  immutable_list/README.md
      create  immutable_list/.gitignore
      create  immutable_list/immutable_list.gemspec
      create  immutable_list/lib/immutable_list.rb
      create  immutable_list/lib/immutable_list/version.rb
Initializating git repo in /Users/gam0022/git/gem/t/immutable_list
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-雛形を編集&#34;&gt;2. 雛形を編集&lt;/h2&gt;

&lt;p&gt;C拡張を自動でコンパイルするようにするために、書き加えないといけないことが多いです。&lt;/p&gt;

&lt;p&gt;Gemfile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; source &#39;https://rubygems.org&#39;

 # Specify your gem&#39;s dependencies in immutable_list.gemspec
 gemspec
+gem &amp;quot;rake-compiler&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rakefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; require &amp;quot;bundler/gem_tasks&amp;quot;
+require &amp;quot;rake/extensiontask&amp;quot;
+
+Rake::ExtensionTask.new &amp;quot;immutable_list&amp;quot; do |ext|
+  ext.lib_dir = &amp;quot;lib/immutable_list&amp;quot;
+end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;immutable_list.gemspec&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# coding: utf-8
 lib = File.expand_path(&#39;../lib&#39;, __FILE__)
 $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
 require &#39;immutable_list/version&#39;

 Gem::Specification.new do |spec|
   spec.name          = &amp;quot;immutable_list&amp;quot;
   spec.version       = ImmutableList::VERSION
   spec.authors       = [&amp;quot;gam0022&amp;quot;]
   spec.email         = [&amp;quot;gam0022@gmail.com&amp;quot;]
-  spec.description   = %q{TODO: Write a gem description}
-  spec.summary       = %q{TODO: Write a gem summary}
+  spec.description   = %q{Immutable Linked List implemented in C-Extensions}
+  spec.summary       = %q{Immutable Linked List implemented in C-Extensions}
   spec.homepage      = &amp;quot;&amp;quot;
   spec.license       = &amp;quot;MIT&amp;quot;
+  spec.extensions    = %w[ext/immutable_list/extconf.rb]

   spec.files         = `git ls-files`.split($/)
   spec.executables   = spec.files.grep(%r{^bin/}) { |f| File.basename(f) }
   spec.test_files    = spec.files.grep(%r{^(test|spec|features)/})
   spec.require_paths = [&amp;quot;lib&amp;quot;]

   spec.add_development_dependency &amp;quot;bundler&amp;quot;, &amp;quot;~&amp;gt; 1.3&amp;quot;
   spec.add_development_dependency &amp;quot;rake&amp;quot;
 end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ext&#34;&gt;ext/&lt;/h2&gt;

&lt;p&gt;C拡張のライブラリ本体は、&lt;code&gt;ext/&lt;/code&gt;に置きます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ext/&lt;/code&gt; は無いので、新規で作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree ext/
ext
└── immutable_list
    ├── extconf.rb
    └── immutable_list.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;immutable_list/immutable_list&lt;/code&gt;のようなファイル名の指定がテクニックなので注目してください。
&lt;code&gt;&amp;lt;gemname&amp;gt;/&amp;lt;gemname&amp;gt;&lt;/code&gt;にすることで、require をするときに名前が衝突することを防いでいます。&lt;/p&gt;

&lt;p&gt;ext/immutable_list/extconf.rb&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &amp;quot;mkmf&amp;quot;
create_makefile(&amp;quot;immutable_list/immutable_list&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ext/immutable_list/immutable_list.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ruby.h&amp;gt;

#define true 1
#define false 0

VALUE cImmutableList;

struct immutable_list {
  VALUE value;
  VALUE next;
};

static void
immutable_list_mark(struct immutable_list *ptr)
{
  rb_gc_mark(ptr-&amp;gt;value);
  rb_gc_mark(ptr-&amp;gt;next);
}

// 長すぎるので以下略。気になる人は以下を参照
// https://github.com/gam0022/immutable_list/blob/master/ext/immutable_list/immutable_list.c
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lib&#34;&gt;lib/&lt;/h2&gt;

&lt;p&gt;通常のgemであれば、&lt;code&gt;lib/immutable_list.rb&lt;/code&gt; に本体を実装しますが、
今回はC拡張で実装されたもの require するようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree lib/
lib
├── immutable_list
│   └── version.rb
└── immutable_list.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lib/immutable_list.rb&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; require &amp;quot;immutable_list/version&amp;quot;
+require &amp;quot;immutable_list/immutable_list&amp;quot;

-module ImmutableList
+class ImmutableList
   # Your code goes here...
 end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lib/immutable_list/version.rb&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-module ImmutableList
+class ImmutableList
  VERSION = &amp;quot;0.0.1&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rubygems-に登録&#34;&gt;RubyGems に登録&lt;/h2&gt;

&lt;p&gt;あとは、通常のgemと同じ要領で、RubyGems に公開するだけです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ gem build immutable_list.gemspec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GitHub に push&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ gem push pkg/immutable_list-0.0.1.gem&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rails4のアプリをHerokuで動かす</title>
      <link>https://gam0022.net/blog/2013/09/17/run-rails4-on-heroku/</link>
      <pubDate>Tue, 17 Sep 2013 22:09:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/09/17/run-rails4-on-heroku/</guid>
      <description>&lt;p&gt;Rails4のアプリをHerokuで動かすまでにしたことをメモします。&lt;/p&gt;

&lt;h1 id=&#34;1-rails4-のプロジェクトを作る&#34;&gt;1. Rails4 のプロジェクトを作る&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://guides.rubyonrails.org/getting_started.html&#34;&gt;Getting Started with Rails&lt;/a&gt;を参考にして Rails4 のプロジェクトを作りました。&lt;/p&gt;

&lt;p&gt;念の為にバージョンもメモしておきます。&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;ruby&lt;/dt&gt;
&lt;dd&gt;ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin12.4.0]&lt;/dd&gt;
&lt;dt&gt;rails&lt;/dt&gt;
&lt;dd&gt;Rails 4.0.0&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Mac OS X でやりました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-heroku-に登録&#34;&gt;2. Heroku に登録&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.heroku.com/&#34;&gt;heroku.com&lt;/a&gt; に 登録して、Heroku のコマンドラインツールをインストールして、公開鍵を登録したような記憶があります。&lt;/p&gt;

&lt;p&gt;(あまり記憶に無いので、たぶん指示に従っていけばいい感じだったと思います。)&lt;/p&gt;

&lt;h1 id=&#34;3-production用のdb-を-sqlite3-pg-に変更&#34;&gt;3. production用のDB を sqlite3 → pg に変更&lt;/h1&gt;

&lt;p&gt;Heroku では SQLite3 に対応してないので、production用のデータベースに PostgreSQL(pg) を使うために &lt;code&gt;Gemfile&lt;/code&gt;と&lt;code&gt;config/databae.yml&lt;/code&gt;を編集します。&lt;/p&gt;

&lt;p&gt;Gemfile の diff&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;gem &#39;rails&#39;, &#39;4.0.0&#39;

# Use sqlite3 as the database for Active Record
-gem &#39;sqlite3&#39;
+gem &#39;sqlite3&#39;, groups: %w(test development), require: false
+gem &#39;pg&#39;, groups: %w(production), require: false

# Use SCSS for stylesheets
gem &#39;sass-rails&#39;, &#39;~&amp;gt; 4.0.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;config/database.yml の diff&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  timeout: 5000

production:
-  adapter: sqlite3
-  database: db/production.sqlite3
+  adapter: pg
+  database: db/production.pg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、&lt;code&gt;bundle install&lt;/code&gt;をします。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;ちなみに、SQLite3 のままで、&lt;code&gt;git push heroku&lt;/code&gt;すると、こんな感じのエラーが起こりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;       Gem files will remain installed in /tmp/build_8njhwta846es/vendor/bundle/ruby/2.0.0/gems/sqlite3-1.3.8 for inspection.
       Results logged to /tmp/build_8njhwta846es/vendor/bundle/ruby/2.0.0/gems/sqlite3-1.3.8/ext/sqlite3/gem_make.out
       An error occurred while installing sqlite3 (1.3.8), and Bundler cannot continue.
       Make sure that `gem install sqlite3 -v &#39;1.3.8&#39;` succeeds before bundling.
 !
 !     Failed to install gems via Bundler.
 !
 !     Detected sqlite3 gem which is not supported on Heroku.
 !     https://devcenter.heroku.com/articles/sqlite3
 !

 !     Push rejected, failed to compile Ruby/Rails app

To git@heroku.com:pacific-waters-7608.git
 ! [remote rejected] master -&amp;gt; master (pre-receive hook declined)
error: failed to push some refs to &#39;git@heroku.com:pacific-waters-7608.git&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-git-リポジトリを作る&#34;&gt;4. Git リポジトリを作る&lt;/h1&gt;

&lt;p&gt;普通に Git リポジトリを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git init
git add .
git commit -m &amp;quot;first commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;5-heroku-に-deploy-する&#34;&gt;5. Heroku に deploy する&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;heroku create # このとき、`heroku create アプリ名` で、任意のアプリ名にもできる。
git push heroku # Heroku への deploy は git の commit で行うよう。時間がかかる。
heroku open # ブラウザで確認できる。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;補足-1&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;git push heroku&lt;/code&gt; に失敗して、&lt;code&gt;heroku create&lt;/code&gt; しているうちに、アプリが5個を越えてしまったので、
&lt;a href=&#34;https://dashboard.heroku.com/apps&#34;&gt;heroku dashbord&lt;/a&gt; からアプリを消していたら、
push 先の heroku(リモートリポジトリ) が無いとかいうエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push heroku

 !  No such app as pacific-waters-7608.

fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなってしまったら、&lt;code&gt;.git/config&lt;/code&gt; を書き換えて、&lt;code&gt;[remote &amp;quot;heroku&amp;quot;]&lt;/code&gt;の部分を消してから、もう一度 &lt;code&gt;heroku create&lt;/code&gt;すればいいです。&lt;/p&gt;

&lt;p&gt;もしくは、url の部分を 存在するアプリ名に書き換えてもいい気がします。&lt;/p&gt;

&lt;h1 id=&#34;6-heroku-のデータベースで-rake-db-migrate-する&#34;&gt;6. Heroku のデータベースで rake db:migrate する&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;heroku open&lt;/code&gt;して、動作を確認すれば分かると思いますが、このままだと Heroku 側のDBが空なので、エラーになります。&lt;/p&gt;

&lt;p&gt;なので、Heroku で rake db:migrate します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;heroku run rake db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;7-ハマった点&#34;&gt;7. ハマった点&lt;/h1&gt;

&lt;p&gt;localでは動くのに、Herokuだとそのままだと上手くいかない場合があります。&lt;/p&gt;

&lt;p&gt;そんな場合は、次のように&lt;code&gt;config/environments/production.rb&lt;/code&gt;の設定を書き換えて、もう一度&lt;code&gt;git push heroku&lt;/code&gt;しましょう。&lt;/p&gt;

&lt;h2 id=&#34;cssやjsが読み込めない場合&#34;&gt;CSSやJSが読み込めない場合&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;config/environments/production.rb&lt;/code&gt; 内で &lt;code&gt;config.assets.compile = true&lt;/code&gt;にします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config/environments/production.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;   # config.assets.css_compressor = :sass

   # Do not fallback to assets pipeline if a precompiled asset is missed.
-  config.assets.compile = false
+  config.assets.compile = true

   # Generate digests for assets URLs.
   config.assets.digest = true

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;public-以下のファイルが404になる場合&#34;&gt;public 以下のファイルが404になる場合&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;config/environments/production.rb&lt;/code&gt; 内で &lt;code&gt;config.serve_static_assets = true&lt;/code&gt;にします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config/environments/production.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;   # config.action_dispatch.rack_cache = true

   # Disable Rails&#39;s static asset server (Apache or nginx will already do this).
-  config.serve_static_assets = false
+  config.serve_static_assets = true

   # Compress JavaScripts and CSS.
   config.assets.js_compressor = :uglifier
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;完&#34;&gt;完&lt;/h1&gt;

&lt;p&gt;これでやっと Heroku で Rails4 を動かせるようになりました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;heroku open&lt;/code&gt; で確認しましょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQLite3でハマった点まとめ</title>
      <link>https://gam0022.net/blog/2013/09/16/sqlite3-memo/</link>
      <pubDate>Mon, 16 Sep 2013 14:05:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/09/16/sqlite3-memo/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://gam0022.net/app/tmg/&#34;&gt;Twitter名刺ジェネレータ&lt;/a&gt;を作るにあたって、
ActiveRecord と SQLite3 を使ったので、勉強になったことを適当にメモします。&lt;/p&gt;

&lt;p&gt;関連記事&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gam0022.net/blog/2013/09/16/canvas-memo/&#34;&gt;Canvasでハマった点まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;activerecord-は-initialize-が遅すぎて-cgi-には使えない&#34;&gt;ActiveRecord は initialize が遅すぎて CGI には使えない&lt;/h1&gt;

&lt;p&gt;ActiveRecord をCGIで単体で使おうとしたのですが、ActiveRecord の初期化に数秒かかってしまい、
レスポンスが遅すぎて使い物になりませんでした。&lt;/p&gt;

&lt;p&gt;結局、&lt;a href=&#34;https://github.com/gam0022/twitter-meishi-generator/blob/master/posts.rb&#34;&gt;ActiveRecord の部分を生のSQLite3で再実装&lt;/a&gt;しました。&lt;/p&gt;

&lt;p&gt;Rails のようにサーバが起動したらずっと同じプロセスで動作するようなものであれは、初期化が遅くても問題にはならないのですが、
CGI のように、appache が毎回プロセスを起動するようなものだと、ActiveRecord を使うのは諦めたほうがいいようです。&lt;/p&gt;

&lt;p&gt;ActiveRecord の悪口になってしまいましたが、ActiveRecord そのものは本当に便利でした。&lt;/p&gt;

&lt;p&gt;テーブルの作成のために ActiveRecord を使うのはいいかもしれないと思いました。&lt;/p&gt;

&lt;h1 id=&#34;sqlite3-を-cgi-で使うときはパーミッション注意&#34;&gt;SQLite3 を CGI で使うときはパーミッション注意&lt;/h1&gt;

&lt;p&gt;SQLite3(というか、ActiveRecordの問題なのだろうか。要検証。) を CGI から使うときは、パーミッションに注意しないと、ハマります。&lt;/p&gt;

&lt;p&gt;以下のような例外が起きることが有りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SQLite3::CantOpenException: unable to open database file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLite3::ReadOnlyException: attempt to write a readonly database&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上のような例外が発生した場合、次のことを確認して下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;データベースファイルのオーナーが appache のユーザになっているか？

&lt;ul&gt;
&lt;li&gt;appache のユーザとグループが &lt;code&gt;www-data&lt;/code&gt; で、データベースのファイル名が &lt;code&gt;db/db.sqlite3&lt;/code&gt; なら、以下のように変更する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chown www-data.www-data db/db.sqlite3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;データベースファイルを置くディレクトリのパーミッションが 777 になっているか?

&lt;ul&gt;
&lt;li&gt;例えば、データベースのファイル名が &lt;code&gt;db/db.sqlite3&lt;/code&gt; なら、ディレクトリ&lt;code&gt;db&lt;/code&gt;のパーミッションは 777 である必要があるようです。
&lt;a href=&#34;http://d.hatena.ne.jp/yun_kichi/20100113/1263362175&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sqlite3で-time-を渡す時には文字列にしないとダメ&#34;&gt;SQLite3で、Time を渡す時には文字列にしないとダメ&lt;/h1&gt;

&lt;p&gt;Ruby で &lt;code&gt;sqlite3 gem&lt;/code&gt; を使ってtableにプレースホルダを使って&lt;code&gt;insert&lt;/code&gt; した時、
&lt;code&gt;can&#39;t prepare Time&lt;/code&gt;とかいうエラーが発生するときは、値を文字列に変換してやると解消するかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Timeクラスを直接渡すと、can&#39;t prepare Time とか言われる例
h = {:time =&amp;gt; Time.now, :data = &amp;quot;なんとかかんとか&amp;quot;}
db.execute(&amp;quot;insert into table(time, data) values (:time, :data)&amp;quot;, h)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のように、Time クラスを直接渡さずに、明示的に文字列に変換してから渡すと解消するかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Timeクラスを文字列に変換して渡すと解消するかも
h = {:time =&amp;gt; Time.now.to_s, :data = &amp;quot;なんとかかんとか&amp;quot;}
db.execute(&amp;quot;insert into table(time, data) values (:time, :data)&amp;quot;, h)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;sqlite3で-結果を-hash-で取る&#34;&gt;SQLite3で、結果を Hash で取る&lt;/h1&gt;

&lt;p&gt;Rubyの&lt;code&gt;sqlite3 gem&lt;/code&gt;で、&lt;code&gt;db.results_as_hash = ture&lt;/code&gt; にすると、
select文などの結果が配列ではなく、Hash で返るようになるので、プログラムの可読性などが向上します。&lt;/p&gt;

&lt;h1 id=&#34;hash-の中身を-ドット演算子-で参照できるようにする&#34;&gt;Hash の中身を ドット演算子 で参照できるようにする&lt;/h1&gt;

&lt;p&gt;SQLite3は関係ないですが、覚えておくと便利だと思ったので、メモします。&lt;/p&gt;

&lt;p&gt;ActiveRecord で実装した部分を SQLite3 で再実装するとき、変更範囲を小さくしたかったので利用したテクニックです。&lt;/p&gt;

&lt;p&gt;(ActiveRecordの結果はクラスだが、SQLite3の結果は &lt;code&gt;db.results_as_hash = ture&lt;/code&gt;した場合、
Hash なので、なんとか既存のコードを変更せずに対応させたかった。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Hash の中身を ドット演算子 で参照したい(キーがString)
class Hash
  def method_missing(n)
    self[n.to_s]
  end
end

h = {&amp;quot;a&amp;quot; =&amp;gt; 1, &amp;quot;b&amp;quot; =&amp;gt; 2, &amp;quot;c&amp;quot; =&amp;gt; 3}

puts h[&amp;quot;b&amp;quot;] # =&amp;gt; 2
puts h.b    # =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、ハッシュのキーがシンボルのときは、次のようにすればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Hash の中身を ドット演算子 で参照したい(キーがSymbol)
class Hash
  def method_missing(n)
    self[n.to_sym]
  end
end

h = {:a =&amp;gt; 1, :b =&amp;gt; 2, :c =&amp;gt; 3}

puts h[:b]
puts h.b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;method_missing&lt;/code&gt;を使った黒魔術なので、速度的に気になる点もありますが、そこは目をつぶりましょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RubyでLinkedListを使うためのC拡張を作った</title>
      <link>https://gam0022.net/blog/2013/08/19/ruby-linkedlist/</link>
      <pubDate>Mon, 19 Aug 2013 21:25:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/08/19/ruby-linkedlist/</guid>
      <description>

&lt;h1 id=&#34;追記&#34;&gt;追記&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;7&lt;/sub&gt; RubyGemsとして公開。クラス名はImmutableListに変更。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rubygems.org/gems/immutable_list&#34;&gt;RubyGems.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/immutable_list/blob/master/README.md&#34;&gt;README(GitHub)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;22&lt;/sub&gt; クラス名が変わったり、この記事では説明不足の部分があったので、記事を書き直しました。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gam0022.net/blog/2013/10/22/immutable-list-gem/&#34;&gt;Rubyで関数型プログラミングをするための ImmutableList Gem を公開&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;RubyのC拡張として &lt;code&gt;LinkedList&lt;/code&gt; (連結リスト) を実装しました。&lt;/p&gt;

&lt;p&gt;Ruby の &lt;code&gt;Array&lt;/code&gt; は 配列で実装されているため、長いリストでの先頭への要素を追加(&lt;code&gt;cons&lt;/code&gt;)や連結(&lt;code&gt;append&lt;/code&gt;)が非常に遅いのをなんとかしたいと思いました。&lt;/p&gt;

&lt;p&gt;用途としては、Rubyで再帰を使って関数型言語風にプログラムを組むことを想定しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gam0022/linkedlist/blob/master/linkedlist.c&#34;&gt;ソースコード&lt;/a&gt;はGitHubに置きました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gam0022/linkedlist&#34;&gt;gam0022/linkedlist (GitHub)&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;車輪の再発明じゃないの&#34;&gt;車輪の再発明じゃないの?&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;gem search linked_list&lt;/code&gt; で調べてみたところ、次の2つのgemが見つかりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;circular_linked_list (0.0.1)&lt;/li&gt;
&lt;li&gt;linked_list (1.0.0)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;しかし、どちらも Ruby で実装されていたので、Cの拡張として実装し直す意味はあるのではないかと思います。&lt;/p&gt;

&lt;h1 id=&#34;使用例&#34;&gt;使用例&lt;/h1&gt;

&lt;p&gt;OCaml の &lt;code&gt;List&lt;/code&gt; に影響を受けて実装したので、次のようなメソッドがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cons&lt;/li&gt;
&lt;li&gt;head&lt;/li&gt;
&lt;li&gt;tail&lt;/li&gt;
&lt;li&gt;rev_append&lt;/li&gt;
&lt;li&gt;rev&lt;/li&gt;
&lt;li&gt;append&lt;/li&gt;
&lt;li&gt;length&lt;/li&gt;
&lt;li&gt;nth&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、Ruby風の名前の文字列や配列への変換、空リストの判定をするメソッドもあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;inspect(to_s)&lt;/li&gt;
&lt;li&gt;to_a&lt;/li&gt;
&lt;li&gt;empty?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;動作確認&#34;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;以下のような動作をします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;linkedlist&#39;

p LinkedList.new # =&amp;gt; ()

p l1 = LinkedList.new.cons(1).cons(2).cons(3) # =&amp;gt; (3, 2, 1)
p l1.head # =&amp;gt; 3
p l1.tail # =&amp;gt; (2, 1)

p l2 = LinkedList[1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;] #=&amp;gt; (1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)

p l1.rev_append(l2) #=&amp;gt; (1, 2, 3, 1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)
p l1.rev #=&amp;gt; (1, 2, 3)
p l3 = l1.append(l2) #=&amp;gt; (3, 2, 1, 1, 2, 3, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)

p l3.length # =&amp;gt; 8
p LinkedList[].length #=&amp;gt; 0

p l3.nth(0) #=&amp;gt; 3
p l3[7] #=&amp;gt; &amp;quot;b&amp;quot;
p l3[100] #=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;クイックソート&#34;&gt;クイックソート&lt;/h2&gt;

&lt;p&gt;せっかくなので、&lt;code&gt;LinkedList&lt;/code&gt;を使って関数型言語風にクイックソートを書いてみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# qsort_sample.rb
require &#39;linkedlist&#39;

def divide(a, l, lt, ge)
  if l.empty?
    [lt, ge]
  elsif l.head &amp;lt; a
    divide(a, l.tail, lt.cons(l.head), ge)
  else
    divide(a, l.tail, lt, ge.cons(l.head))
  end
end

def qsort(l)
  if l.empty?
    LinkedList.new
  else
    lt, ge = divide(l.head, l.tail, LinkedList.new, LinkedList.new)
    qsort(lt) + qsort(ge).cons(l.head)
  end
end

l = LinkedList[3, 5, 8, 1, 4, 7, 10, -3, 2, 100, 43, 10, 50]
p qsort(l) #=&amp;gt; (-3, 1, 2, 3, 4, 5, 7, 8, 10, 10, 43, 50, 100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cons などが、演算子になっていないせいで可読性が少し低いですが、それなりに綺麗にクイックソートが書けます。&lt;/p&gt;

&lt;h1 id=&#34;ベンチマーク結果&#34;&gt;ベンチマーク結果&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;と&lt;code&gt;LinkedList&lt;/code&gt;で、先頭に長さ3のリストを 連結する処理にかかった秒数を、連結した回数ごとにまとめました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;連結回数&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Array&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;LinkedList&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.5e-05&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.0e-05&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.007251&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00166&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.727542&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.015206&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;100000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;102.080825&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.414083&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;この測定には、&lt;a href=&#34;https://github.com/gam0022/linkedlist/blob/master/benchmark.rb&#34;&gt;benchmark.rb&lt;/a&gt; を用いました。&lt;/p&gt;

&lt;p&gt;クラス名を変えただけのコードですが、
リストの長さが長くなるほど、&lt;code&gt;Array&lt;/code&gt;よりも&lt;code&gt;LinkedList&lt;/code&gt; の方が相対的に高速になります。&lt;/p&gt;

&lt;p&gt;まあ、連結リストに圧倒的に有利な操作で測定しているので当然ですが&amp;hellip;&lt;/p&gt;

&lt;p&gt;ともかく、これで速度を気にせずにappendやconsをバリバリ使うことができます!&lt;/p&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;struct linkedlist&lt;/code&gt; の定義など見ればわかると思いますが、かなりシンプルな実装になりました。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.loveruby.net/w/RubyExtensionProgrammingGuide.html&#34;&gt;RubyExtensionProgrammingGuide&lt;/a&gt; がとても参考になりました。&lt;/li&gt;
&lt;li&gt;WBなどはしていないので、&lt;a href=&#34;http://www.atdot.net/~ko1/activities/RubyKaigi2013-ko1.pdf&#34;&gt;RGenGC&lt;/a&gt; に対応できてるか不安です。

&lt;ul&gt;
&lt;li&gt;そもそも、どの関数も破壊的ではないので、WBが発生するタイミングが無い?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;余裕が無かったので、セーフレベルやオブジェクトの汚染など、セキュリティのことは全く考えてません。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; や &lt;code&gt;tail&lt;/code&gt; や &lt;code&gt;nth&lt;/code&gt; で要素がない場合ですが、すべて&lt;code&gt;nil&lt;/code&gt;を返すようにして、例外は発生させないことにしました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;インストール方法&#34;&gt;インストール方法&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/gam0022/linkedlist.git
$ cd linkedlist
# インストール先のrubyで extconf.rb を実行する
$ ruby extconf.rb
$ make
$ make install
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rubyの改造してThread#joinのTimeoutで例外を発生させる</title>
      <link>https://gam0022.net/blog/2013/08/18/ruby-thread-join/</link>
      <pubDate>Sun, 18 Aug 2013 17:15:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/08/18/ruby-thread-join/</guid>
      <description>

&lt;h1 id=&#34;ぼっちupcamp&#34;&gt;ぼっちupcamp&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/search?q=%23upcamp&amp;amp;src=hash&#34;&gt;#upcamp&lt;/a&gt; に参加しようと思ったのですが、
諸事情により行けなくなったので、一人で何か作ってました。&lt;/p&gt;

&lt;p&gt;Ruby の 処理系の動作の改良(改悪)をしていました。&lt;/p&gt;

&lt;p&gt;Ruby は &lt;code&gt;git clone https://github.com/ruby/ruby.git&lt;/code&gt; で落としたものを使いました。&lt;/p&gt;

&lt;h1 id=&#34;thread-join-で-タイムアウトしたときに例外を発生させる&#34;&gt;Thread#join で タイムアウトしたときに例外を発生させる&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://doc.ruby-lang.org/ja/2.0.0/method/Thread/i/join.html&#34;&gt;Thread#join&lt;/a&gt;は、
スレッド self の実行が終了するまで、カレントスレッドを停止させるメソッドです。
limit を指定して、limit 秒過ぎても自身が終了しない場合、nil を返します。&lt;/p&gt;

&lt;p&gt;今回は、limit 秒を過ぎてタイムアウトした場合、
例外&lt;code&gt;Timeout&lt;/code&gt; を発生させるように改造しました。&lt;/p&gt;

&lt;p&gt;正直、自分でもネタをミスった感がありますが、
すこしはタイムアウトした場合の処理が楽に書けるようになる気がします。&lt;/p&gt;

&lt;h2 id=&#34;従来のrubyの-thread-join-でタイムアウトを処理する&#34;&gt;従来のRubyの Thread#join でタイムアウトを処理する&lt;/h2&gt;

&lt;p&gt;まず、従来のRubyの &lt;code&gt;Thread#join&lt;/code&gt; でタイムアウトを処理する場合のコード例を示します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Thread#join&lt;/code&gt;の返り値が &lt;code&gt;nil&lt;/code&gt;のときにタイムアウトしたと分かるので、
このように書けると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;begin
  t = Thread.start {
    # 1秒で終わらない処理
    while true
      1
    end
  }
  isTimeout = (t.join(1) == nil)
rescue ThreadError
  puts &amp;quot;theread error&amp;quot;
ensure
  puts &amp;quot;timeout error&amp;quot; if isTimeout

  t.kill
end

# =&amp;gt; &amp;quot;timeout error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;改造したrubyの-thread-join-でタイムアウトを処理する&#34;&gt;改造したRubyの Thread#join でタイムアウトを処理する&lt;/h2&gt;

&lt;p&gt;今回の改造によって、次のようにRubyのコードをスッキリさせることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;begin
  t = Thread.start {
    # 1秒で終わらない処理
    while true
      1
    end
  }
  t.join(1)
rescue TimeoutError
  puts &amp;quot;timeout error&amp;quot;
rescue ThreadError
  puts &amp;quot;theread error&amp;quot;
ensure
  t.kill
end

# =&amp;gt; &amp;quot;timeout error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例外処理が &lt;code&gt;rescue&lt;/code&gt; 節にまとまって、コードが見やすくなります。&lt;/p&gt;

&lt;h1 id=&#34;変更箇所&#34;&gt;変更箇所&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/include/ruby/ruby.h b/include/ruby/ruby.h
index 575a2b6..79e4289 100644
--- a/include/ruby/ruby.h
+++ b/include/ruby/ruby.h
@@ -1646,6 +1646,7 @@ RUBY_EXTERN VALUE rb_eRuntimeError;
 RUBY_EXTERN VALUE rb_eSecurityError;
 RUBY_EXTERN VALUE rb_eSystemCallError;
 RUBY_EXTERN VALUE rb_eThreadError;
+RUBY_EXTERN VALUE rb_eTimeoutError;
 RUBY_EXTERN VALUE rb_eTypeError;
 RUBY_EXTERN VALUE rb_eZeroDivError;
 RUBY_EXTERN VALUE rb_eNotImpError;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/eval.c b/eval.c
index 0bf8337..1304ad0 100644
--- a/eval.c
+++ b/eval.c
@@ -694,6 +694,8 @@ rb_iterator_p(void)
     return rb_block_given_p();
 }

+
+VALUE rb_eTimeoutError;
 VALUE rb_eThreadError;

 void
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/thread.c b/thread.c
index 4f1f409..1bdd657 100644
--- a/thread.c
+++ b/thread.c
@@ -821,7 +821,7 @@ thread_join(rb_thread_t *target_th, double delay)
        target_th-&amp;gt;join_list = &amp;amp;list;
        if (!rb_ensure(thread_join_sleep, (VALUE)&amp;amp;arg,
                       remove_from_join_list, (VALUE)&amp;amp;arg)) {
-           return Qnil;
+            rb_raise(rb_eTimeoutError, &amp;quot;timeout in Thread#join.&amp;quot;);
        }
     }

@@ -5103,6 +5103,7 @@ Init_Thread(void)

     recursive_key = rb_intern(&amp;quot;__recursive_key__&amp;quot;);
     rb_eThreadError = rb_define_class(&amp;quot;ThreadError&amp;quot;, rb_eStandardError);
+    rb_eTimeoutError = rb_define_class(&amp;quot;TimeoutError&amp;quot;, rb_eStandardError);

     /* init thread core */
     {
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;感想とか&#34;&gt;感想とか&lt;/h1&gt;

&lt;p&gt;思ったことを箇条書きで適当に。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;そもそも、タイムアウトで例外を発生させる動作が妥当なのか。

&lt;ul&gt;
&lt;li&gt;スレッドプログラミングをほとんどしたことがないので分からないのですが、例外が発生すると不便なこともあるんですかね?&lt;/li&gt;
&lt;li&gt;C# の &lt;code&gt;Thread.join()&lt;/code&gt; でも、bool 型の返り値によって、true なら正常終了、false ならタイムアウトとなっていて、
現状のRubyと同じような仕様になっていました。&lt;/li&gt;
&lt;li&gt;詳しい人がもしいたら、コメントほしいです。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;苦労した点

&lt;ul&gt;
&lt;li&gt;特に無かったのですが、Thread#join の定義箇所を見つけるのに苦労しました。&lt;/li&gt;
&lt;li&gt;というか、2,3行しかプログラムを書いてない&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rubyのgitリポジトリ</title>
      <link>https://gam0022.net/blog/2013/08/04/ruby-git/</link>
      <pubDate>Sun, 04 Aug 2013 11:39:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/08/04/ruby-git/</guid>
      <description>&lt;p&gt;RubyってSubversionで開発してるというイメージしか無かったのですが、GitHubでも最新のソースコードをCloneできました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/ruby/ruby.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公式にリポジトリガイドなるページがあるので、最新のRubyのソースコードを読んでみたい人は参考にしたらいいと思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruby-lang.org/ja/documentation/repository-guide/&#34;&gt;レポジトリガイド&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初心者が混乱しやすいRubyの変数</title>
      <link>https://gam0022.net/blog/2013/02/09/ruby-variable/</link>
      <pubDate>Sat, 09 Feb 2013 19:07:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2013/02/09/ruby-variable/</guid>
      <description>

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Rubyの初心者にありがちなことだと思うが、
変数を代入した時や関数を呼び出した時に、値渡しであるか参照渡しであるか混乱すると思う。&lt;/p&gt;

&lt;p&gt;私もよくわからずにかつては混乱した。&lt;/p&gt;

&lt;p&gt;次のページを見つけてようやく頭の整理がついた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rubyのメソッドの引数は値渡しで、Rubyの変数は全てオブジェクトを指し示すポインタに似た何かだと考えればよいのだ。
&lt;a href=&#34;http://d.hatena.ne.jp/eel3/20110214/1297690699&#34;&gt;引数の参照渡し（変数渡し）なのか単なるオブジェクトへの参照なのか、それが問題&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;なるほどわかりやすい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rubyのメソッドの引数は値渡し&lt;/li&gt;
&lt;li&gt;Rubyの変数は全てオブジェクトを指し示すポインタに似た何か&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;rubyの変数はラベル&#34;&gt;Rubyの変数はラベル&lt;/h1&gt;

&lt;p&gt;Cにおける変数は箱だと例えられるが、Rubyにおける変数はラベルと例えられることがある。&lt;/p&gt;

&lt;p&gt;Cの変数では、メモリ上の箱に値がそのまま入っている。代入をすれば、箱が複製される。&lt;/p&gt;

&lt;p&gt;一方、Rubyではメモリ上の箱のどこかに値が入っており、変数はラベル(箱への参照)を持っているだけにすぎない。
変数を代入すると、メモリ上のデータはそのままに、ラベルだけがコピーされるのである。&lt;/p&gt;

&lt;h2 id=&#34;破壊的操作で意図しない変更が起きる例&#34;&gt;破壊的操作で意図しない変更が起きる例&lt;/h2&gt;

&lt;p&gt;次の例のようにbにaを代入した後、aに破壊的変更をすると、bの値まで変わってしまう。&lt;/p&gt;

&lt;p&gt;なぜならば、aとbは同じラベルを持っているので、同じ箱を共有した状態にあるからだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 破壊的操作でbに意図しない変更が起こる例
[1] pry(main)&amp;gt; a = &amp;quot;abc&amp;quot;
=&amp;gt; &amp;quot;abc&amp;quot;
[2] pry(main)&amp;gt; b = a
=&amp;gt; &amp;quot;abc&amp;quot;
[3] pry(main)&amp;gt; a.reverse!
=&amp;gt; &amp;quot;cba&amp;quot;
[4] pry(main)&amp;gt; b
=&amp;gt; &amp;quot;cba&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;回避方法1&#34;&gt;回避方法1&lt;/h2&gt;

&lt;p&gt;bの値を変えたくなければ、破壊的操作をしなければ良い。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a = a.reverse&lt;/code&gt;とすれば、インスタンス&lt;code&gt;&amp;quot;cba&amp;quot;&lt;/code&gt;が作られ、aにそのラベルが入る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 破壊的操作をしなければbは変わらない
[1] pry(main)&amp;gt; a = &amp;quot;abc&amp;quot;
=&amp;gt; &amp;quot;abc&amp;quot;
[2] pry(main)&amp;gt; b = a
=&amp;gt; &amp;quot;abc&amp;quot;
[3] pry(main)&amp;gt; a = a.reverse
=&amp;gt; &amp;quot;cba&amp;quot;
[4] pry(main)&amp;gt; b
=&amp;gt; &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;回避方法2&#34;&gt;回避方法2&lt;/h2&gt;

&lt;p&gt;または、&lt;code&gt;b = a&lt;/code&gt;ではなく、&lt;code&gt;b = a.dup&lt;/code&gt;とすれば、別のインスタンス&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;が作られ、bにそのラベルが入る。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a[1] = &amp;quot;b&amp;quot;&lt;/code&gt;のように、どうしても破壊的な変更をしないといけないときには必要だ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# dupを使って深いコピーをする
[1] pry(main)&amp;gt; a = &amp;quot;abc&amp;quot;
=&amp;gt; &amp;quot;abc&amp;quot;
[2] pry(main)&amp;gt; b = a.dup
=&amp;gt; &amp;quot;abc&amp;quot;
[3] pry(main)&amp;gt; a.reverse!
=&amp;gt; &amp;quot;cba&amp;quot;
[4] pry(main)&amp;gt; b
=&amp;gt; &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;rubyのメソッドの引数は値渡し&#34;&gt;Rubyのメソッドの引数は値渡し&lt;/h1&gt;

&lt;p&gt;Rubyのメソッドの引数は値渡しだと言ったが、渡される値はラベルである。&lt;/p&gt;

&lt;p&gt;だから、メソッドの中で破壊的操作をすれば、意図しない変更が起こる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# メソッドでも破壊的操作で意図しない変更が起きる例
[1] pry(main)&amp;gt; def hoge(p)
[1] pry(main)*   p.reverse!
[1] pry(main)* end  
=&amp;gt; nil
[2] pry(main)&amp;gt; a = &amp;quot;abc&amp;quot;
=&amp;gt; &amp;quot;abc&amp;quot;
[3] pry(main)&amp;gt; hoge(a)
=&amp;gt; &amp;quot;cba&amp;quot;
[4] pry(main)&amp;gt; a
=&amp;gt; &amp;quot;cba&amp;quot;
[5] pry(main)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回避方法は先程と同じで、破壊的操作をしなければ良いだけである。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;補足だが、関数の中で仮引数に別の値を代入しても、実引数には影響がない。&lt;/p&gt;

&lt;p&gt;なぜならば、仮引数pに&amp;rdquo;hoge&amp;rdquo;を代入しても、
これまで説明したルール通り、pの参照先が上書きされただけなので、
実引数aの指す値には影響がないからである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#  仮引数に再代入しても、実引き数には影響がない例
[1] pry(main)&amp;gt; def hoge(p)
[1] pry(main)*   p = &amp;quot;hoge&amp;quot;
[1] pry(main)* end  
=&amp;gt; nil
[2] pry(main)&amp;gt; a = &amp;quot;abc&amp;quot;
=&amp;gt; &amp;quot;abc&amp;quot;
[3] pry(main)&amp;gt; hoge(a)
=&amp;gt; &amp;quot;hoge&amp;quot;
[4] pry(main)&amp;gt; a #影響がない
=&amp;gt; &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おまけ-rubyにインクリメント演算子がない理由&#34;&gt;おまけ：Rubyにインクリメント演算子がない理由&lt;/h1&gt;

&lt;p&gt;Rubyにインクリメント演算子がない理由は簡単で、RubyのFixnumクラスやBignumクラスは immutableだからだ。&lt;/p&gt;

&lt;p&gt;つまり、オブジェクト自体を破壊的に変更することはできない。&lt;/p&gt;

&lt;p&gt;もし、オブジェクト自体を破壊的に変更できたらどうなるだろうか。&lt;/p&gt;

&lt;p&gt;大変なことになってしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# インクリメント演算子のあるRuby
[1] pry(main)&amp;gt; a = 1
=&amp;gt; 1
[2] pry(main)&amp;gt; b = a
=&amp;gt; 1
[3] pry(main)&amp;gt; a++
=&amp;gt; 2
[4] pry(main)&amp;gt; a
=&amp;gt; 2
[5] pry(main) b
=&amp;gt; 2
[6] pry(main) 1
=&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;1 = 2&lt;/code&gt;が成立してしまう。&lt;/p&gt;

&lt;p&gt;もちろん、実際のRubyではエラーになってしまうので、こんなことはありえない。&lt;/p&gt;

&lt;p&gt;インクリメント演算子はC言語などのように、変数に値が入っている言語なら問題ない。&lt;/p&gt;

&lt;p&gt;しかし、Rubyのように数値までオブジェクトとなっている言語では、
インスタンスの値を変更できてしまうと、大変なことになってしまう。&lt;/p&gt;

&lt;p&gt;だから、immutable にするしかない。&lt;/p&gt;

&lt;p&gt;ちなみに、Rubyでは&lt;code&gt;i += 1&lt;/code&gt;のような演算子がある。&lt;/p&gt;

&lt;p&gt;これはどうみても破壊的だしどうなっているんだと思ったが、シンタックスシュガーらしい。&lt;/p&gt;

&lt;p&gt;つまり、こういうことだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;i += 1 # i = i + 1 と解釈される
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうせなら、&lt;code&gt;i++&lt;/code&gt;もシンタックスシュガーにしてしまえばいいじゃないかと思うのは私だけだろうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WEBrickを使って、RubyCGIをローカル上でテストする</title>
      <link>https://gam0022.net/blog/2012/08/25/preview-ruby-cgi-using-webrick/</link>
      <pubDate>Sat, 25 Aug 2012 11:19:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2012/08/25/preview-ruby-cgi-using-webrick/</guid>
      <description>

&lt;p&gt;WEBrickを使って、RubyCGIをローカル上でプレビューする方法を紹介します。前にTwinCalを作った時にこの方法を覚えました。&lt;/p&gt;

&lt;p&gt;ApacheはC言語で書かれていているために&lt;a href=&#34;http://thinkit.co.jp/article/117/4?page=0,1&#34;&gt;パフォーマンスが良い&lt;/a&gt;ので本番環境ではApacheを採用しましたが、
ローカルでテスト用に使うにはWEBrickでちょろっとサーバを立てるのが良いですよね、そうしましょう。&lt;/p&gt;

&lt;p&gt;テスト環境(ローカル)
:WEBrick&lt;/p&gt;

&lt;p&gt;本番環境(サーバ)
:Apache&lt;/p&gt;

&lt;p&gt;あとは、rsyncとかでファイルを同期できるようにしたら完璧。&lt;/p&gt;

&lt;h3 id=&#34;1-rubyのパスを本番環境とテスト環境で統一する&#34;&gt;1. Rubyのパスを本番環境とテスト環境で統一する&lt;/h3&gt;

&lt;p&gt;Rubyのパスを本番環境とテスト環境で統一するために、
&lt;code&gt;/usr/bin/ruby&lt;/code&gt;のシンボリックリンクをrvmなどで入れたRubyに置き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mv /usr/bin/ruby /usr/bin/ruby-original
ln -s /Users/gam0022/.rvm/rubies/ruby-1.9.3-p194/bin/ruby /usr/bin/ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本番環境とテスト環境の両方で行います。&lt;/p&gt;

&lt;p&gt;当然ですが、RubyのCGIではこのパスを1行目に指定します。&lt;/p&gt;

&lt;h3 id=&#34;2-webrickを使う&#34;&gt;2. WEBrickを使う&lt;/h3&gt;

&lt;p&gt;WEBrickについて簡単に説明すると、RubyでWEBサーバを立てるためのライブラリです。
これをrequireすることで、10行くらいのコードを書くだけで簡易WEBサーバが完成します。&lt;/p&gt;

&lt;p&gt;私の場合、次のような&lt;code&gt;preview.rb&lt;/code&gt;を書きました。
WEBrickで.rbをAddHandlerする方法がなかなかわからなくて苦労しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webrick&#39;
include WEBrick

module WEBrick::HTTPServlet
  FileHandler.add_handler(&#39;rb&#39;, CGIHandler)
end

s = HTTPServer.new(
  :Port =&amp;gt; 3000,
  :DocumentRoot =&amp;gt; File.join(Dir.pwd),
  :DirectoryIndex =&amp;gt; [&#39;index.rb&#39;]
)
trap(&amp;quot;INT&amp;quot;) { s.shutdown }
s.start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;preview.rb&lt;/code&gt;を公開したいディレクトリに設置し、
ターミナルで&lt;code&gt;ruby preview.rb&lt;/code&gt;をすれば、ブラウザで&lt;code&gt;localhost:3000&lt;/code&gt;にアクセスすることで、
簡単にローカル上でCGIをテストすることができます。&lt;/p&gt;

&lt;h3 id=&#34;おまけ-webrickでrequesturitoolargeが発生したときの対処方法&#34;&gt;おまけ: WEBrickでRequestURITooLargeが発生したときの対処方法&lt;/h3&gt;

&lt;p&gt;ApacheではURIの上限が大きいので、かなり長いURIを発行しても問題がないのですが、WEBrickでは2083byteの制限があるので、
CGIで長いURIを発行すると、RequestURITooLargeというエラーになってしまうことがあります。&lt;/p&gt;

&lt;p&gt;これは、WEBrickのソースコードを書き換えることで対処できます。&lt;/p&gt;

&lt;p&gt;私の環境では、&lt;code&gt;/usr/local/rvm/rubies/ruby-1.9.3-p194/lib/ruby/1.9.1/webrick/httprequest.rb&lt;/code&gt;のL293に、
&lt;code&gt;MAX_URI_LENGTH&lt;/code&gt;という定数があったので、これを書き換えることで対処できました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;291     private
292 
293     MAX_URI_LENGTH = 20830#2083 # :nodoc:
294 
295     def read_request_line(socket)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://mukaer.com/archives/2012/03/19/rubywebrickrequ/&#34;&gt;RubyでWebrick利用時にRequestURITooLargeエラー発生時の対処&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Twinsに登録した時間割をGoogleカレンダーやiCalにインポートするWebサービス「TwinCal」を作った</title>
      <link>https://gam0022.net/blog/2012/08/22/twincal/</link>
      <pubDate>Wed, 22 Aug 2012 12:47:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2012/08/22/twincal/</guid>
      <description>&lt;p&gt;Rubyで何かWebアプリを作ってみたかったので、
Twinsに登録した時間割をGoogleカレンダーやiCalにインポートするWebサービス「TwinCal」を作ってみました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gam0022.net/app/twincal/&#34;&gt;TwinCal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;筑波大学生以外にも分かるように説明すると、筑波大学にはTwinsという履修の登録をするWebのシステムがあり、
Twinsでは時間割をCSV出力する機能があるので、そのCSVをiCalender形式に変換して、
GoogleカレンダーやiCalにインポートをサポートするWebアプリを作りました。&lt;/p&gt;

&lt;p&gt;来年、Twinsが改修されるらしいので、半年後には使えなくなると思います。&lt;/p&gt;

&lt;p&gt;バイトでPHPを使ってWebアプリを開発した経験はありましたが、個人でWebアプリを作ったのは初めてでした。&lt;/p&gt;

&lt;p&gt;気を使ったこととして、ビューの部分はerb(railsでも使われているアレ)を使い、MVCを意識して作りました。&lt;/p&gt;

&lt;p&gt;最近流行りのbootstrapやjQueryなどを使ったのですが、この2つを使ったのは正解でした。
これらのおかげでロジック部分に集中することができ、かなりサクサク作業することができました。&lt;/p&gt;

&lt;p&gt;このアプリを作ろうと思い立ったのは12日で、14日には公開できるような状態になりました。&lt;/p&gt;

&lt;p&gt;あまり使ってくれている人はいないようですが、bootstrapとhtml5で遊べたことだけでもよい経験となりました。&lt;/p&gt;

&lt;p&gt;今回のことで学んだテクニックがいくつかあるので、後ほど記事にしたいです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
